<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Basic Design - ODIN</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="the Open Data Integration Framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../odin.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../about.html">About this Document</a></li><li class="chapter-item expanded "><a href="../install.html">Installation</a></li><li class="chapter-item expanded "><a href="../intro.html">1. Introduction</a></li><li class="chapter-item expanded "><a href="../sys_crates.html">2. System Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../odin_build/odin_build.html">odin_build</a></li><li class="chapter-item "><a href="../odin_action/odin_action.html">odin_action</a></li><li class="chapter-item expanded "><a href="../odin_actor/odin_actor.html">odin_actor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../odin_actor/actor_basics.html">Actor Programming Model</a></li><li class="chapter-item expanded "><a href="../odin_actor/actor_impl.html" class="active">Basic Design</a></li><li class="chapter-item "><a href="../odin_actor/actor_communication.html">Actor Communication</a></li><li class="chapter-item "><a href="../odin_actor/examples/examples.html">Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../odin_actor/examples/hello_world.html">hello_world</a></li><li class="chapter-item "><a href="../odin_actor/examples/sys_msgs.html">sys_msgs</a></li><li class="chapter-item "><a href="../odin_actor/examples/spawn.html">spawn</a></li><li class="chapter-item "><a href="../odin_actor/examples/spawn_blocking.html">spawn_blocking</a></li><li class="chapter-item "><a href="../odin_actor/examples/exec.html">exec</a></li><li class="chapter-item "><a href="../odin_actor/examples/jobs.html">jobs</a></li><li class="chapter-item "><a href="../odin_actor/examples/producer_consumer.html">producer_consumer</a></li><li class="chapter-item "><a href="../odin_actor/examples/pub_sub.html">pub_sub</a></li><li class="chapter-item "><a href="../odin_actor/examples/pin_pong.html">ping_pong</a></li><li class="chapter-item "><a href="../odin_actor/examples/query.html">query</a></li><li class="chapter-item "><a href="../odin_actor/examples/dyn_actor.html">dyn_actor</a></li><li class="chapter-item "><a href="../odin_actor/examples/actions.html">actions</a></li><li class="chapter-item "><a href="../odin_actor/examples/dyn_actions.html">dyn_actions</a></li><li class="chapter-item "><a href="../odin_actor/examples/retry.html">retry</a></li><li class="chapter-item "><a href="../odin_actor/examples/requests.html">requests</a></li><li class="chapter-item "><a href="../odin_actor/examples/actor_config.html">actor_config</a></li><li class="chapter-item "><a href="../odin_actor/examples/heartbeat.html">heartbeat</a></li></ol></li></ol></li><li class="chapter-item "><a href="../odin_server/odin_server.html">odin_server</a></li></ol></li><li class="chapter-item expanded "><a href="../app_crates.html">3. Application Domain Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../odin_hrrr/odin_hrrr.html">odin_hrrr</a></li><li class="chapter-item "><a href="../odin_sentinel/odin_sentinel.html">odin_sentinel</a></li><li class="chapter-item "><a href="../odin_goesr/odin_goesr.html">odin_goesr</a></li></ol></li><li class="chapter-item expanded "><a href="../glossary.html">Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ODIN</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="basic-design"><a class="header" href="#basic-design">Basic Design</a></h1>
<p>This chapter describes how the general actor constructs introduced in <a href="actor_basics.html">actor_basics</a> are implemented in <code>odin_actor</code>,
which reflects our major design choices:</p>
<ul>
<li>map each actor into a dedicated <a href="https://rust-lang.github.io/async-book/">async task</a> that owns the actor state</li>
<li>use an actor specific enum type to define the set of messages that can be sent to/are processed by this actor
(each message type is wrapped into a tuple struct variant of this enum)</li>
<li>use bounded <a href="https://doc.rust-lang.org/rust-by-example/std_misc/channels.html">multi-producer/single-consumer (MPSC) channels</a>
of this message set enum to implement actor mailboxes</li>
<li>wrap the sender part of the channel into a (cloneable) actor handle and move the receiver part and the actor state into
the task function, which loops to process received messages</li>
<li>use normal enum matching to dispatch messages from within the actor task</li>
<li>use the actor handle to send messages to the associated actor</li>
</ul>
<p>This ensures our basic requirements:</p>
<ul>
<li>actor message interfaces can be checked at compile time - we can only send messages to actors who process them, and
each actor processes all of the message types in its interface</li>
<li>actor state cannot accidentally leak from within its task (neither during construction nor while sending messages)</li>
<li>actors can process concurrently (and - depending on async runtime and hardware - in parallel)</li>
<li>message processing back pressure is propagated (bounded channel write blocks until receiver is ready), the system related
memory per actor is bounded (no out-of-memory conditions because of "hung" actors)</li>
</ul>
<p>The remainder of this page looks at each of the actor elements: messages, mailboxes, actors (handles and state) and actor systems.</p>
<h2 id="messages-and-actor-message-sets"><a class="header" href="#messages-and-actor-message-sets">Messages and Actor Message Sets</a></h2>
<p>Messages are ordinary structs, they do not require any <code>odin_actor</code> specific overhead other than that they for obvious reasons
have to be <code>Send</code> and have to implement <code>Debug</code> (<code>odin_actor</code> requirement to support debug/logging).</p>
<p>The <code>odin_actor</code> crate does define a number of <em>system messages</em> for lifetime control and monitoring purposes (<code>_Start_</code>,
<code>_Pause_</code>, <code>_Resume_</code>, <code>_Timer_</code>, <code>_Exec_</code>, <code>_Ping_</code>, <code>_Terminate_</code>). Those messages do not have to be handled explicitly by actors (although
they can, should the actor require specific actions). System messages can be sent to any actor.</p>
<p><em>Message sets</em> are the complete message interfaces of their associated actors. They are implemented as <code>enums</code> since we
want to be able to statically (at compile time) check that</p>
<ul>
<li>an actor processes all message types in its interface (no "forgotten" messages)</li>
<li>we can only send messages to actors who have this message type in their interface</li>
</ul>
<p>Other than for actor definition message set enums are mostly transparent, which means they need <code>From&lt;msg-type&gt;</code> impls for all their
variants. Message sets have to include the system messages mentioned above. Since this would be tedious to define explicitly we provide
the <code>define_actor_msg_set!(..)</code> macro that can be used like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use odin_actor::prelude::*;

#[derive(Debug)] struct MsgA(usize);
#[derive(Debug)] struct MsgB(usize);

define_actor_msg_set! { MyActorMsg = MsgA | MsgB }
...
<span class="boring">}</span></code></pre></pre>
<p>This gets expanded to an enum type with <code>From&lt;T&gt;</code> impls for each of its variants:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
enum MyActorMsg {
    MsgA(MsgA),
    MsgB(MsgB)
}
impl From&lt;MsgA&gt; for MyActorMsg {...}
impl From&lt;MsgB&gt; for MyActorMsg {...}
...
<span class="boring">}</span></code></pre></pre>
<p>The macro also adds variants for the system messages so that we can send them to each actor.</p>
<p>Apart from automatic <code>From&lt;..&gt;</code> impls the main operation performed on message set enums is matching their variants inside of
actor <code>receive()</code> functions. To avoid boilerplate and to make the code more readable we provide support matching on variant
types from within the <code>impl_actor! {..}</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl_actor! { match msg for Actor&lt;MyActor,MyActorMsg&gt; as
    MsgA =&gt; cont! { 
        // process msg: MyActorMsg::MsgA
    }
    ...
    _Start_ =&gt; cont! {
        // process msg: MyActorMsg::_Start_
    }
<span class="boring">}</span></code></pre></pre>
<p>However, Rust enum variants are <em>not</em> types, hence the framework automatically has to map type names (from the match arm patterns)
to variant identifiers, which requires name mangling in case of generic types and tuples. This name mangling is performed automatically
and uses similar valid unicode identifier characters (see <code>odin_macro</code> implementation) to ensure that compiler error messages are still
readable.</p>
<p>It should be noted that since we use <code>enums</code> to define message sets developers should be aware of the variant type sizes - Rust enums
are sized to accommodate the largest of their variants and mailboxes represent arrays of respective message set enums. Use <code>Arc&lt;MyLargeType&gt;</code> in case variants can get large.</p>
<h2 id="mailboxes"><a class="header" href="#mailboxes">Mailboxes</a></h2>
<p>Mailboxes are implemented as Rust <code>channels</code>, i.e. <code>odin_actor</code> does not provide its own type and uses (transparently) whatever the
configured channel implementation default to (e.g. <a href="https://docs.rs/flume/latest/flume/fn.bounded.html"><code>flume::bounded</code></a>). This is
controlled at build time by <code>odin_actor</code> features (currently <code>tokio_kanal</code> or <code>tokio_flume</code>).</p>
<p>The <code>odin_actor</code> crates uses bounded channels, i.e. we do not support dynamically sized mailboxes. The rationale is to use mailbox
bounds for back pressure control and to prevent out-of-memory errors at runtime. This also means we have to support three types
of message sends:</p>
<ul>
<li>async send (potentially blocking until space becomes available)</li>
<li>try_send (non-blocking but fails if mailbox is full)</li>
<li>timeout_send (async with a specified max timeout - in between the above two choices)</li>
</ul>
<h2 id="actorhandle"><a class="header" href="#actorhandle">ActorHandle</a></h2>
<p><code>ActorHandle</code> is a system provided struct with a type parameter that represents the actor message set type. This type
is used to define the sender-part of the actor mailbox (mpsc channel - see <a href="#actor">Actor</a> section below), which in
turn is what makes our actor message interfaces type safe (at compile time).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ActorHandle &lt;M&gt; where M: MsgTypeConstraints {
    pub id: Arc&lt;String&gt;,
    hsys: Arc&lt;ActorSystemHandle&gt;,
    tx: MpscSender&lt;M&gt; // internal - this is channel specific
}
<span class="boring">}</span></code></pre></pre>
<p>Since <code>ActorHandle</code> is primarily used to send messages to the corresponding actor the main functions in its inherent impl are:</p>
<ul>
<li><code>async fn send_msg&lt;T&gt; (&amp;self, msg: T)-&gt;Result&lt;()&gt; where T: Into&lt;M&gt; {...}</code></li>
<li><code>async fn timeout_send_msg&lt;T&gt; (&amp;self, msg: T, to: Duration)-&gt;Result&lt;()&gt; where T: Into&lt;M&gt; {...}</code></li>
<li><code>pub fn try_send_msg&lt;T&gt; (&amp;self, msg:T)-&gt;Result&lt;()&gt; where T: Into&lt;M&gt; {...}</code></li>
</ul>
<p>Note that all are generic in the message type <code>T: Into&lt;M&gt;</code>, i.e. any type for which the respective actor message set <code>M</code>
has a <code>From</code> trait impl (which our <code>define_actor_msg_set!(..)</code> macro automatically generates).</p>
<p><code>ActorHandles</code> have one basic requirement - they have to be inexpensive to clone. For that reason we use <code>Arc&lt;T&gt;</code> references
to store the id (name) and the <code>ActorSystemHandle</code> of the respective actor.</p>
<p><code>ActorHandles</code> are not created explicitly - they are the return values of <code>spawn_actor!{..}</code> or <code>spawn_pre_actor!{..}</code> macro
calls.</p>
<p>The system also provides a <code>PreActorHandle&lt;M&gt;</code> struct that allows explicit construction in case we have cyclic dependencies
between actors. The sole purpose of <code>PreActorHandle</code> is to subsequently create <code>ActorHandles</code> from it. To that end it creates
and stores both sender and receiver parts of the actor task channel but it does not allow to use them - all its fields are private
and are just used as a temporary cache. The <code>spawn_pre_actor!{..}</code> macro is used to spawn actors from respective <code>PreActorHandles</code>.</p>
<h2 id="actor-state"><a class="header" href="#actor-state">Actor State</a></h2>
<p>Just like the for the message types <code>odin_actor</code> accepts any <code>struct</code> as actor state, without the need for any specific
fields or trait impls.</p>
<p>There usually is an associated inherent impl for such structs which defines the functional interface of the actor. A common
pattern is to use minimal code in the actor impl itself and just call actor state methods from the message match expressions
like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyActor {...}

impl MyActor {
    fn process_msg_a (&amp;mut self, msg: MsgA) {
        ...
    }
    ...
}

impl_actor! { match msg for Actor&lt;MyActor,MyActorMsg&gt; as
    MsgA =&gt; cont! { 
        self.process_msg_a( msg)
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="actor"><a class="header" href="#actor">Actor</a></h2>
<p>The <code>odin_actor</code> crate uses a single generic actor type</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Actor &lt;S,M&gt; where S: Send + 'static, M: MsgTypeConstraints {
    pub state: S,
    pub hself: ActorHandle&lt;M&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>where the type variable <code>S</code> represents the user defined actor state type and the type variable <code>M</code> represents the actor
message set type defined by a corresponding <code>define_actor_msg_set!(..)</code> invocation. The <code>Actor</code> type itself is mostly transparent,
usually it is only visible at the location where a concrete actor is defined with the <code>impl_actor! { ... }</code> macro.</p>
<p>To avoid boilerplate in the associated message matcher code <code>odin_actor</code> provides blanket <code>Deref</code> and <code>DerefMut</code> impls that
forward to the <code>state: S</code> field. For the most part, developers can treat actor and actor state synonymously.</p>
<p>One consequence of not having constraints on the actor state type and keeping system related data in the framework provided
<code>Actor&lt;S,M&gt;</code> struct is that we need to pass actor handles into inherent impl methods like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyActor {...}

impl MyActor {
    async fn send_something (&amp;mut self, hself: &amp;ActorHandle&lt;MyActorMsg&gt;) {
        hself.send_msg(...).await
    }
    ...
}

impl_actor! { match msg for Actor&lt;MyActor,MyActorMsg&gt; as
    ... =&gt; cont! { 
        self.send_something( &amp;self.hself).await
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>We define concrete <code>Actor</code> types by means of our <code>impl_actor!{..}</code> macro, which has the primary purpose of generating
a <code>ActorReceiver&lt;M&gt;</code> trait impl for the concrete <code>Actor</code> type. This trait defines the function</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn receive (&amp;mut self, msg: MsgType)-&gt; impl Future&lt;Output = ReceiveAction&gt; + Send
<span class="boring">}</span></code></pre></pre>
<p>which is our actor message dispatcher (a matcher on the actor message set enum variants).</p>
<p>Once it is spawned at runtime the <code>Actor</code> is moved into its own Tokio task. Since the <code>Actor</code> owns the actor state <code>S</code> this
guarantees actor encapsulation - it is not visible to the outside anymore. The task in turn consists of a loop that awaits
incoming messages from the actor mailbox (task channel reader part) and then dispatches the message through the <code>receive()</code>
function of the <code>ActorReceiver</code> impl.</p>
<p>Each <code>receive</code> match arm has to return a <code>ReceiveAction</code> enum that tells the task how to proceed:</p>
<ul>
<li><code>ReceiveAction::Continue</code> continues to loop, waiting for the next message to receive</li>
<li><code>ReceiveAction::Stop</code> breaks the loop and terminates message processing for this actor. This is the default
result when dispatching <code>_Terminate_</code> system messages</li>
<li><code>ReceiveAction::RequestTermination</code> sends a termination request to the associated <code>ActorSystem</code> but continues
to loop. The <code>ActorSystem</code> in turn sends <code>_Terminate_</code> messages to all its actors in response</li>
</ul>
<p>The system provides the <code>cont!{..}</code>, <code>stop!{..}</code> and <code>term!{..}</code> macros as syntatic sugar to make sure match arm expressions
do return respective <code>ReceiveAction</code> values.</p>
<h2 id="actorsystem"><a class="header" href="#actorsystem">ActorSystem</a></h2>
<p>Spawning actor tasks and transferring ownership of its <code>Actors</code> is the responsibility of the system provided <code>ActorSystem</code>
struct. Its main function therefore is <code>spawn_actor(..)</code> which is normally just called by the <code>spawn_actor!{..}</code> macro that
transparently</p>
<ul>
<li>creates a MPSC channel for the actor message set type</li>
<li>creates an <code>ActorHandle</code> that stores the sender part of the channel</li>
<li>creates an <code>Actor</code> from the provided actor state object and the <code>ActorReceiver</code> impl generated by the associated
<code>impl_actor!{..}</code> call (which means it has to be in scope at the point of the <code>spawn_actor{..}</code> call so that the
compiler can deduce the message type set)</li>
<li>spawns a new task with the system provided <code>run_actor(..)</code> task function, moving both the <code>Actor</code> and the receiver
part of the MPSC channel into this task</li>
</ul>
<p>The <code>ActorSystem</code> also keeps track of all running actors as a list of <code>SysMsgReceiver</code> trait objects. This means
<code>ActorSystem</code> can only interact with <code>Actors</code> by sending system messages. For this purpose <code>ActorSystem</code> has its own
task that processes <code>ActorSystemRequest</code> messages, of which the <code>ActorSystemRequest::RequestTermination</code> (sent by
<code>run_actor</code> in response to a <code>ReceiveAction::RequestTermination</code> return value from the actor <code>receive()</code> function) is
the most common one.</p>
<p>Based on its list of <code>SysMsgReceivers</code> the <code>ActorSystem</code> also manages heart beats (system liveness monitoring) and
a build-time configurable user interface to display the system status. Both are transparent to the application.</p>
<p><code>ActorSystem</code> is the primary object for actor based applications, which all follow the same general structure:</p>
<pre><pre class="playground"><code class="language-rust">...

#[tokio::main]
async fn main() -&gt;Result&lt;()&gt; {
    // create the actor system
    let mut actor_system = ActorSystem::new("main");

    // spawn actors
    let handle_a = spawn_actor!( actor_system, "A", ActorA{..})?;
    let handle_b = spawn_actor!( actor_system, "B", ActorB{..})?;
    ...

    // run the actor system
    actor_system.start_all().await?;
    actor_system.process_requests().await?;

    Ok(())
}</code></pre></pre>
<p>There are two underlying abstractions that can be varied for an <code>ActorSystem</code> implementation: async runtime and actor
task channel type. Both are configured by a <a href="https://doc.rust-lang.org/cargo/reference/features.html">Cargo build feature</a>
and provide the same interface. At this time we support</p>
<ul>
<li>the default <code>tokio_kanal</code> (<a href="https://tokio.rs/">Tokio</a> runtime and <a href="https://crates.io/crates/kanal">Kanal</a> MPSC channel type)</li>
<li><code>tokio_flume</code> (using the <a href="https://docs.rs/flume/latest/flume/">Flume</a> MPSC channel type)</li>
</ul>
<p>Within the same process only one combination can be used.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../odin_actor/actor_basics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../odin_actor/actor_communication.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../odin_actor/actor_basics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../odin_actor/actor_communication.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
