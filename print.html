<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ODIN</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="the Open Data Integration Framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="odin.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about.html">About this Document</a></li><li class="chapter-item expanded "><a href="install.html">Installation</a></li><li class="chapter-item expanded "><a href="intro.html">1. Introduction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design_principles.html">Design Principles</a></li></ol></li><li class="chapter-item expanded "><a href="sys_crates.html">2. System Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="odin_build/odin_build.html">odin_build</a></li><li class="chapter-item "><a href="odin_action/odin_action.html">odin_action</a></li><li class="chapter-item "><a href="odin_actor/odin_actor.html">odin_actor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="odin_actor/actor_basics.html">Actor Programming Model</a></li><li class="chapter-item "><a href="odin_actor/actor_impl.html">Basic Design</a></li><li class="chapter-item "><a href="odin_actor/actor_communication.html">Actor Communication</a></li><li class="chapter-item "><a href="odin_actor/examples/examples.html">Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="odin_actor/examples/hello_world.html">hello_world</a></li><li class="chapter-item "><a href="odin_actor/examples/sys_msgs.html">sys_msgs</a></li><li class="chapter-item "><a href="odin_actor/examples/spawn.html">spawn</a></li><li class="chapter-item "><a href="odin_actor/examples/spawn_blocking.html">spawn_blocking</a></li><li class="chapter-item "><a href="odin_actor/examples/exec.html">exec</a></li><li class="chapter-item "><a href="odin_actor/examples/jobs.html">jobs</a></li><li class="chapter-item "><a href="odin_actor/examples/producer_consumer.html">producer_consumer</a></li><li class="chapter-item "><a href="odin_actor/examples/pub_sub.html">pub_sub</a></li><li class="chapter-item "><a href="odin_actor/examples/pin_pong.html">ping_pong</a></li><li class="chapter-item "><a href="odin_actor/examples/query.html">query</a></li><li class="chapter-item "><a href="odin_actor/examples/dyn_actor.html">dyn_actor</a></li><li class="chapter-item "><a href="odin_actor/examples/actions.html">actions</a></li><li class="chapter-item "><a href="odin_actor/examples/dyn_actions.html">dyn_actions</a></li><li class="chapter-item "><a href="odin_actor/examples/retry.html">retry</a></li><li class="chapter-item "><a href="odin_actor/examples/requests.html">requests</a></li><li class="chapter-item "><a href="odin_actor/examples/actor_config.html">actor_config</a></li><li class="chapter-item "><a href="odin_actor/examples/heartbeat.html">heartbeat</a></li></ol></li></ol></li><li class="chapter-item "><a href="odin_server/odin_server.html">odin_server</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="odin_server/client.html">Server/Client Interaction</a></li><li class="chapter-item "><a href="odin_server/ui_library.html">Web Client UI Library</a></li></ol></li><li class="chapter-item "><a href="odin_cesium/odin_cesium.html">odin_cesium</a></li><li class="chapter-item "><a href="odin_share/odin_share.html">odin_share</a></li><li class="chapter-item "><a href="odin_dem/odin_dem.html">odin-dem</a></li><li class="chapter-item "><a href="odin_gdal/odin_gdal.html">odin-gdal</a></li></ol></li><li class="chapter-item expanded "><a href="app_crates.html">3. Application Domain Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="odin_hrrr/odin_hrrr.html">odin_hrrr</a></li><li class="chapter-item "><a href="odin_sentinel/odin_sentinel.html">odin_sentinel</a></li><li class="chapter-item "><a href="odin_goesr/odin_goesr.html">odin_goesr</a></li></ol></li><li class="chapter-item expanded "><a href="glossary.html">Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ODIN</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-this-document"><a class="header" href="#about-this-document">About this Document</a></h1>
<p>this is the developer documentation for the open source ODIN project. Sources are available in the <code>odin_book</code>
directory of the general ODIN repository at <a href="https://github.com/ODIN-fire/odin-rs">https://github.com/ODIN-fire/odin-rs</a>, which is distributed under the
<a href="https://www.apache.org/licenses/LICENSE-2.0">Apache v2 license</a>.</p>
<p>The html version can be viewed at <a href="http://odin-fire.github.io/odin-rs">http://odin-fire.github.io/odin-rs</a>.</p>
<p>Sources of this book can be rendered and viewed offline by using <a href="https://rust-lang.github.io/mdBook/">mdbook</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-and-install"><a class="header" href="#build-and-install">Build and Install</a></h1>
<p>This Rust repository contains a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo workspace</a> that consists of several sub-crates (<code>odin_actor</code>, <code>odin_config</code>, ..) that can be built or executed separately.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ol>
<li>
<p><a href="https://git-scm.com/">Git</a> - the version control system that is by now ubiqitous</p>
</li>
<li>
<p><a href="https://www.rust-lang.org/tools/install">Rust toolchain</a> - we recommend to manage the toolchain via <code>rustup</code>
At this point ODIN-RS uses the nightly toolchain. To get, (locally) install <code>rustup</code> and switch to the nightly toolchain execute:</p>
<pre><code class="language-shell">$&gt; curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
...
$&gt; rustup default nightly
</code></pre>
<p>To check if the basic Rust installation is working correctly you can create, build and run a simple test project by executing</p>
<pre><code class="language-shell">$&gt; cargo new my_test
    Creating binary (application) `my_test` package
$&gt; cd my_test
$&gt; cargo run
    Compiling my_test v0.1.0 ...
    ...
    Running `target/debug/my_test`
Hello, world!
</code></pre>
<p>Periodic updates of the toolchain can be done by executing <code>rustup update</code></p>
<p>To install the <a href="https://rust-lang.github.io/mdBook/"><code>mdbook</code></a> tool to compile and serve online documentation
please run</p>
<pre><code class="language-shell">$&gt; cargo install mdbook
</code></pre>
<p>If you are new to Rust you can find documentation and tutorials on <a href="https://www.rust-lang.org/learn">https://www.rust-lang.org/learn</a>.
Information about the vast Rust ecosystem of available 3rd party libraries is available on <a href="https://crates.io">https://crates.io</a>.</p>
</li>
<li>
<p><a href="https://gdal.org/">GDAL</a> - this native library is required if you run applications that use  <a href="odin_gdal/odin_gdal.html">odin_gdal</a> to
process external input such as satellite data. The basic examples (e.g. from <code>hello_world</code> from <a href="odin_actor/odin_actor.html">odin_actor`</a>)
do not require it so you can leave this to the <a href="install.html#next-steps">Next Steps</a> section below but ultimately you probably need it for general
odin-rs development so we recommend to install it upfront. GDAL should be installed through the native package manager of your system:</p>
<ul>
<li>Linux: gdal packages are available for all major Linux distributions through their native package managers.
Please note that Ubuntu 20.04 only supported old versions of GDAL which might require to <a href="https://gdal.org/en/latest/development/building_from_source.html#building-from-source">install/build from source</a></li>
<li>macOS: <a href="https://brew.sh/">homebrew</a>: <code>brew install gdal</code> - <strong>make sure to install homebrew in its default location (<code>/opt/homebrew/</code>
on Apple silicon) to avoid build problems with various GDAL dependencies</strong></li>
<li>windows: <a href="https://learn.microsoft.com/en-us/vcpkg/get_started/overview">vcpkg</a></li>
</ul>
</li>
<li>
<p>odin-rs sources - downloadable via <a href="https://git-scm.com/">Git</a> from <a href="https://github.com/ODIN-fire/odin-rs">https://github.com/ODIN-fire/odin-rs</a>:</p>
<pre><code class="language-shell">$&gt; git clone https://github.com/ODIN-fire/odin-rs
</code></pre>
</li>
</ol>
<h3 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h3>
<p>Since many ODIN applications require configuration or other data files at runtime it is recommended to keep the repository
and such files under a single root directory. To conform with the <a href="odin_build/odin_build.html"><code>odin_build</code></a> crate we recommend the
following structure:</p>
<pre><code>.
└── ❬odin-root-dir❭/                    created before cloning odin-rs
    ├── configs/...                       read-only data deserialized into config structs
    ├── assets/...                        read-only binary data served by ODIN app
    ├── data/...                          persistent runtime data for ODIN apps
    ├── cache/...                         transient runtime data for ODIN apps
    │
    └── odin-rs/...                     ⬅︎ directory into which ODIN source repository is cloned
</code></pre>
<p>The name of the ❬odin-root-dir❭ can be chosen at will. You can have several root dirs with different odin versions/branches and/or resource files. An installation as outlined above does not require any environment variables to be set.</p>
<p>Resource directories (configs/, assets/ and data/) can be populated upon demand later-on - please refer to the
<a href="odin_build/odin_build.html"><code>odin_build</code></a> documentation for further details.</p>
<p>On a Unix/macOS system this amounts to a sequence of commands like:</p>
<pre><code class="language-shell">$&gt; mkdir odin
$&gt; cd odin
$&gt; mkdir configs assets data cache
$&gt; git clone https://github.com/ODIN-fire/odin-rs  # or other odin-rs repository URL
...
$&gt; cd odin-rs
</code></pre>
<h3 id="build-instructions"><a class="header" href="#build-instructions">Build instructions</a></h3>
<p>Building and running ODIN-RS executables is normally done through the command line <a href="https://doc.rust-lang.org/cargo/index.html"><code>cargo</code></a> tool which is installed by <code>rustup</code> as mentioned above. While ODIN-RS can be built directly from the directory where this repository was cloned to we recommend to switch to the respective crate you are interested in, e.g.</p>
<pre><code class="language-shell">$&gt; cd odin_actor
$&gt; cargo run --example hello_world
   Compiling ...
   ...
     Running `.../odin-rs/target/debug/examples/hello_world`
hello world!
</code></pre>
<p>For IDEs and editors we recommend:</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/languages/rust">Visual Studio Code with the Rust Analyzer extension</a> - just choose "File-&gt;Open Folder"
with the directory this repository was cloned to and you should be all set</li>
<li><a href="https://zed.dev/">Zed</a> - as a more editor oriented but faster GUI alternative (Zed is implemented in Rust)</li>
<li><a href="https://helix-editor.com/">Helix</a> - is a text-mode editor (i.e. works over ssh) that is implemented in Rust and can be installed as part
of the Rust toolchain</li>
</ul>
<p>To build/browse this documentation you have to install the Rust <a href="https://rust-lang.github.io/mdBook/"><code>mdbook</code></a> tool:</p>
<pre><code class="language-shell">$&gt; cargo install mdbook
...
$&gt; cd odin_book
$&gt; mdbook serve
2024-07-18 10:07:57 [INFO] (mdbook::book): Book building has started
2024-07-18 10:07:57 [INFO] (mdbook::book): Running the html backend
2024-07-18 10:07:57 [INFO] (mdbook::cmd::serve): Serving on: http://localhost:3000
...
</code></pre>
<p>Once the mdbook server is running you can view the latest version of the <code>odin_book</code> contents in any browser at http://localhost:3000</p>
<h3 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h3>
<p>Most likely you are interested in <code>odin-rs</code> to run web applications. If those involve importing external geospatial data (e.g. NetCDF files)
and/or visualization on a virtual globe there are two additional 3rd party dependencies:</p>
<ul>
<li><a href="https://gdal.org/">GDAL</a></li>
<li><a href="https://cesium.com/platform/cesiumjs/">CesiumJS</a></li>
</ul>
<p>The first one is required to read/process many external geospatial data sets such as GOES-R hotspots or NOAA HRRR weather forecasts. There are native GDAL packages for Linux, macOS and Windows but the names depend on your native package manager (e.g. <a href="https://brew.sh/">homebrew</a> on macOS. <a href="https://vcpkg.io/">vcpkg</a> on Windows, or <code>apt-get</code> on Ubuntu Linux).</p>
<p>On macOS using <a href="https://brew.sh/">homebrew</a> this is:</p>
<pre><code class="language-shell">brew install gdal
</code></pre>
<p>The <a href="https://cesium.com/platform/cesiumjs/">CesiumJS</a> install is optional. Per default build option respective <code>odin-rs</code> applications proxy the
CesiumJS server but for production environments it is recommended to download and strip the distribution to speed up load times and reduce
network downloads. The <a href="odin_cesium/odin_cesium.html"><code>odin_cesium</code></a> crate contains a <code>install_cesium</code> tool that can be used like so:</p>
<pre><code class="language-shell"># from within odin-rs/
cd odin_cesium
mkdir -p ../../assets/odin_cesium
cargo run --bin install_cesium
</code></pre>
<p>This should leave you with a populated <code>../../assets/odin_cesium/cesiumjs/</code> directory. Since we do this to have a working production
environment it is also recommended to get a free <a href="https://ion.cesium.com/tokens?page=1">Cesium Ion access token</a>, copy the default
<code>ODIN-ROOT/odin-rs/odin_cesium/assets/odin_cesium_config.js</code> to <code>ODIN-ROOT/assets/odin_cesium/</code> and edit it to set</p>
<pre><code class="language-javascript">Cesium.Ion.defaultAccessToken = "&lt;YOUR ACCESS TOKEN HERE&gt;";
...
</code></pre>
<p>You can read about <em>assets</em> and <em>configs</em> directories in <a href="odin_build/odin_build.html">odin_build</a> and about Cesium in
<a href="odin_cesium/odin_cesium.html">odin_cesium</a>. Other applications/crates (such as <code>odin_sentinel</code>) can require more assets and configs.</p>
<p>The above steps should be enough to run the next install test:</p>
<pre><code class="language-shell">$&gt; cd .../odin_goesr
$&gt; cargo run --bin show_goesr_hotspots
...
    Running `target/release/show_goesr_hotspots`
serving SPA on http://127.0.0.1:9009/goesr
</code></pre>
<p>If you open a browser tab on <code>http://localhost:9009/goesr</code> it should display a virtual globe with live updated hotspots
detected by <a href="https://www.goes-r.gov/">GOES-R</a> satellites (see <a href="odin_goesr/odin_goesr.html">odin_goesr</a> for details). If you
click on the last icon in the upper left corner you should see a window showing the lates GOES-R data sets. If this shows
live data entries it means</p>
<ul>
<li>external data access is working (not blocked by firewall etc.)</li>
<li>your GDAL installation to read this data is working</li>
<li>the CesiumJS browser library is working</li>
</ul>
<p>You can terminate the server with Ctrl-c.</p>
<p>As a last step you can test your local CesiumJS installation (obtained through <code>install_cesium</code>) by re-running the same
application with the respective <code>cesium_asset</code> build feature and release mode optimizations:</p>
<pre><code class="language-shell"> cargo run --features cesium_asset --release --bin show_goesr_hotspots
</code></pre>
<p>At this point you should have a fully functional <code>odin-rs</code> development system.</p>
<h3 id="known-installation-pitfalls"><a class="header" href="#known-installation-pitfalls">Known Installation Pitfalls</a></h3>
<h4 id="macos"><a class="header" href="#macos">MacOS</a></h4>
<h5 id="wrong-or-missing-xcode-command-line-tools"><a class="header" href="#wrong-or-missing-xcode-command-line-tools">wrong or Missing Xcode command line tools</a></h5>
<p>On MacOS Rust does require reasonably updated Xcode command line tools. This problem manifests itself in different ways (e.g. CC link errors)
but early on. You can verify outside of <code>odin-rs</code> by running the <code>cargo new my_test; cd my_test; cargo run</code> test mentioned above.</p>
<p>The xtools command line tools can be installed as part of Xcode from the Apple AppStore or - if you already have Xcode - by running <code>xcode-select –-install</code>.</p>
<h5 id="native-gdal-package-install-fails"><a class="header" href="#native-gdal-package-install-fails">native GDAL package install fails</a></h5>
<p><a href="https://gdal.org/">GDAL</a> is a native library for geospatial image processing with a huge dependency set (tiff, jpeg, png, hdf5, netcdf etc.) and hence is updated quite frequently. It should be installed and updated through a native package manager, e.g. <a href="https://brew.sh/">homebrew</a>.</p>
<p>Since GDAL itself has a lot of dependencies it is highly recommended to use a standard <a href="https://brew.sh/">homebrew</a> installation (which on Apple silicon is in <code>/opt/homebrew/</code>). Non-standard locations might force buiding packages from source, which is prone to fail for complex packages such as python. While it is possible to build and install GDAL manually - and to configure <code>odin-rs</code> accordingly - we do not recommend this as it would still require a working <code>homebrew</code> for the GDAL dependencies. Please refer to the <a href="odin_gdal/odin_gdal.html"><code>odin_gdal</code></a> documentation
for how to build/use GDAL libraries from source.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>ODIN is a software framework to efficiently create servers that support disaster management.</p>
<img class="mono right" src="./img/info-fragmentation.svg" width="40%"/>
<p>More specifically it is a framework to build servers that import and process an open number of external data sources for information such as weather, ground-, aerial- and space-based sensors, threat assessment, simulation, vehicle/crew tracking and many more. The over-arching goal is to improve situational awareness of stakeholders by making more - and more timely - information available in stakeholder-specific applications. The main challenge for this is not the availability of data, it is how this data can be integrated in extensible and customizable applications.</p>
<p>We want to mitigate the <strong>information fragmentation- and compartmentalization problem</strong>. No more hopping between dozens of browser tabs. No more manual refreshes to stay up-to-date. No more printouts to communicate. No more take-it-or-leave-it systems that can't be extended.</p>
<p>ODINs goal is <em>not</em> to create yet another website that is supposed to replace all the ones that already exist. We want to enable stakeholder organizations to assemble <em>their</em> server applictions showing the information <em>they</em> need, with the capability to run those servers/applications on <em>their</em> machines (even out in the field if need be). We also want to do this in a way that makes it easy to integrate new data sources and functions as they become available from government, research organizations and commercial vendors. We want ODIN to be extensible, scalable, portable and - last not least - accessible.</p>
<p>To that end ODIN is open sourced under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache v2 license</a>. It is a library you can use and extend in your projects.</p>
<h2 id="stakeholders"><a class="header" href="#stakeholders">Stakeholders</a></h2>
<img class="mono left" src="./img/stakeholders.svg" width="55%"/>
<p>Our vision for ODIN goes beyond a single stakeholder. We want it to be an open (freely available) platform for both users and developers. The ODIN maintainers are just one part of the puzzle, developing and maintaining the core framework other developers can build on. We only see our role in creating generic components that implement a consistent, extensible and scalable architecture.</p>
<p>User stakeholders are more than just responder organizations (of which there are many). We also envision local communities who want to improve their level of preparedness / disaster planning. Another example would be utility providers monitoring critical infrastructure. The common goal for such user stakeholders is to enhance their situational awareness but what information that entails depends on the specific incident type, stakeholder and location.</p>
<p>What holds for most user stakeholder organizations is that they lack the resources to develop respective systems from scratch. The stakeholders who do have development capacity often find themselves reinventing the wheel. The stakeholders who subscribe to commercial services have no way to tailor or extend such services.</p>
<p>There is no single organization that could develop all service components on its own. Commercial vendors come up with new sensors. Research organizations develop new forecast models and simulators. What holds for all such provider stakeholders is that they want to focus on their specific expertise. They don't want to duplicate existing functions just to make their products available. If they do so it just increases the information fragmentation problem we started with.</p>
<p>ODIN aspires to become the common ground on which stakeholders can meet - free, open and extensible for all.</p>
<h2 id="underlying-sw-architecturedesign"><a class="header" href="#underlying-sw-architecturedesign">Underlying SW Architecture/Design</a></h2>
<img class="mono right" src="./img/actors-mono.svg" width="35%"/>
<p>To be that common basis ODIN needs a strong architectural foundation. Since ODINs main task is to collect and then process data from various independent external sources we need good support for concurrent computation - one of the most challenging topics for software development. ODIN meets this challenge by using the <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Programming Model</a>: asynchronously executing objects which only communicate through messages and don't share internal state (see <a href="odin_actor/odin_actor.html">odin_actor</a> and <a href="odin_actor/actor_basics.html">The Actor Programming Model</a> for details).</p>
<p>ODIN also has to work with existing software. There is a large collection of existing work we want to build on, such as fire-behavior and micro grid wind simulators (e.g. <a href="https://weather.firelab.org/windninja/">WindNinja</a>) and general geospatial data processing libraries (e.g. <a href="https://gdal.org/">GDAL</a>). Given the binary nature of many of the underlying data formats, the need to efficiently use 3rd-party native libraries, the challenges of concurrent programming and the portability we strive for we chose <a href="https://www.rust-lang.org/">Rust</a> as the implementation platform as it gives us</p>
<ul>
<li>language intrinsic memory- and thread- safety</li>
<li>a well defined <a href="https://en.wikipedia.org/wiki/Application_binary_interface">Application Binary Interface</a></li>
<li>a comprehensive cross-platform standard library</li>
<li>a huge external <a href="https://crates.io/">eco-system</a></li>
<li>good asynchronous programming support, both in the language and its libraries</li>
<li>powerful abstraction features for large scale program design</li>
<li>a mature, consistent tool chain (especially including dependency management)</li>
<li>high efficiency / low system overhead (one of Rusts design goals is "zero cost abstraction")</li>
</ul>
<p>What do we want to build on that basis?</p>
<h2 id="odin-application-types"><a class="header" href="#odin-application-types">ODIN Application Types</a></h2>
<p>While ODIN contains all sort of command line tools, the primary targets are three types of applications:</p>
<ul>
<li>user servers - providing data visualization for end users</li>
<li>edge servers - factoring out network-, compute- and data volume-intense tasks to dedicated machinery</li>
<li>monitors - listening on sensor data and potentially sending out alarm notifications</li>
</ul>
<p>All are built from the same ODIN components and follow the same architectural design outlined above.</p>
<h3 id="user-servers"><a class="header" href="#user-servers">User Servers</a></h3>
<p>ODIN user servers are not supposed to handle millions of requests from large numbers of simultaneous but isolated users. The servers we mainly target support medium size workgroups of stakeholder users (&lt;1000) with the need for:</p>
<ul>
<li>automatic data update (also for low latency tracking data)</li>
<li>collaboration (synchronized views)</li>
</ul>
<p>The main application model for user servers is a <a href="https://en.wikipedia.org/wiki/Single-page_application">Single Page Application</a>. The main user interface is a web browser - ODIN does not require end user installation and can be used on existing machinery.</p>
<img class="mono left" src="./img/odin-spa-mono.svg" width="45%"/>
<p>A Single Page Application (SPA) mainly uses two types of actors: importers and a SPAServer. An Importer is a dedicated component to handle a single external data source, including data retrieval schedule and translation into ODIN internal format (if required). Importers are completely independent of each other which makes it simple to add new ones. Their results are sent via messages to a SPA-Server actor that distributes the information to connected users.</p>
<p>The SPA-Server actor utilizes MicroService objects that are managing static and dynamic content which is shown as separate layers on the served web page. Static content mostly consists of HTML and associated Javascript modules. It can be initialized from files or compiled into stand-alone executables and is served via http(s) protocol.</p>
<p>Stand alone ODIN SPA servers do not require any additional files/installation other than the executable itself (see <a href="odin_build/odin_build.html">odin_build</a> for details). They can be thought of as traditional desktop applications that just use a browser as the user interface.</p>
<p>To ensure realtime update of low latency data (down to 1Hz) such as tracked objects ODIN utilizes <a href="https://en.wikipedia.org/wiki/WebSocket">WebSockets</a> that are managed by the MicroService objects, and processed in the browser by ODINs Javascript modules (assets).</p>
<p>For geospatial display in the browser ODIN uses the open source <a href="https://cesium.com/platform/cesiumjs/">CesiumJS</a> library, which is built on top of <a href="https://en.wikipedia.org/wiki/WebGL">WebGL</a> and hence supports hardware accelerated 3D graphics to display a virtual globe.</p>
<p>ODINs user interface components such as (movable) windows, lists and buttons are implemented with ODINs own Javascript library that resembles a traditional desktop and is highly (user-) configurable.</p>
<h3 id="edge-servers"><a class="header" href="#edge-servers">Edge Servers</a></h3>
<p>ODIN edge servers are the means to make ODIN applications scalable - they provide condensed/consolidated input data for user servers by factoring out high computational workloads and/or large input data volumes into dedicated machines with high speed network access. Edge servers are primarily used to reduce downstream processing and data volume.</p>
<img class="mono right" src="./img/odin-edge-mono.svg" width="45%"/>
<p>Assume for instance micro-grid (location/terrain- aware) wind forecast for a given incident area, such as provided by <a href="https://weather.firelab.org/windninja/">WindNinja</a>. This not only requires high speed machinery to execute the simulation but also needs significant bandwidth/connectivity to periodically obtain the required input data such as weather forecasts and station reports, high resolution digital elevation models, vegetation/fuel models and more. The user-facing results of the simulation can be compiled into relatively simple text (CSV) files containing a wind vector grid in the area of interest.</p>
<p>As a general rule we want to be able to run functions where the data is most easily accessible. For information that is obtained from sensors in the field (such as local tracking data) that can be a local incident command server. For functions that use large amounts of input such as NOAA weather forecasts this can be a high speed data center. For functions that are computationally expensive this should be a super computer.</p>
<h3 id="monitors"><a class="header" href="#monitors">Monitors</a></h3>
<img class="mono right" src="./img/odin-monitor-mono.svg" width="45%"/>
<p>This class of applications mostly automates alarm notifications by monitoring sensor input to detect critical conditions, vetting them by sensor data post-processsing or retrieval of supporting evidence, eliminating duplicates, and then sending out notifications via 3rd party notification channels such as text messages or <a href="https://slack.com/">Slack</a> channels.</p>
<p>Sensor input can be obtained from directly connected devices or from own or external edge servers.</p>
<p>Monitors can combine/correlate different sensor systems (e.g. ground based and satellite sensors).</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>To get an idea of what ODIN servers might look like on end user machines we refer to two of our TFRSAC talks:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=b9DfMBYCe-s&amp;t=4950s">spring 2023</a></li>
<li><a href="https://www.youtube.com/watch?v=gCBXOaybDLA">fall 2022</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h1>
<p>To keep a complex and multi-disciplinary framework such as odin-rs consistent we have to adhere to a set of
general design principles. The dominant ones for odin-rs are listed below.</p>
<h2 id="use-existing-libraries"><a class="header" href="#use-existing-libraries">Use existing libraries</a></h2>
<p>The use of odin-rs generally falls into the cross section of several application domains such as</p>
<ul>
<li>(web) server/client development</li>
<li>serialization/deserialization</li>
<li>geo-spatial processing</li>
<li>physical computation</li>
<li>data visualization and user interfaces</li>
<li>asynchronous programming</li>
</ul>
<p>The <a href="https://crates.io">Rust ecosystem</a> contains substantial libraries for all these domains. Wherever
these libraries are stable, maintained, widely adopted and license compatible <code>odin-rs</code> should use them
to avoid not-invented-here syndrome. Not doing so means to dramatically increase the size of <code>odin-rs</code>
with functions that probably won't be based on the same domain expertise and won't be as well tested.</p>
<p>Using 3rd party libaries does come with caveats, namely dependency management and interface/type consistency.</p>
<p>To avoid <a href="https://en.wikipedia.org/wiki/Dependency_hell">dependency/version hell</a> we have to ensure that</p>
<p>(1) we use Rust crates instead of native libraries wherever possible so that we can rely on the Rust build
system to manage versions and features. This also means we can statically compile/link those dependencies
which greatly reduces the risk of version hell.</p>
<p>(2) we try to keep the number of 3rd party dependencies low by using only established crates.</p>
<p>To mitigate the interface/type consistency problem that comes with using partly overlapping 3rd party libraries
we use Rust language features, namely <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a> and the
<a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html"><em>NewType</em> pattern</a>. The goal
is to use Rust's "zero cost abstraction" features to add adapters that imply minimal (if any) runtime costs.
The caveat here is to be aware where this might involve copying of aggregates and collections.</p>
<p>As of this time the strategic 3rd party crates used by <code>odin-rs</code> are:</p>
<ul>
<li>server/client development: <a href="https://docs.rs/axum/latest/axum/">Axum</a> and <a href="https://docs.rs/reqwest/latest/reqwest/">Reqwest</a></li>
<li>serialization/deserialization: <a href="https://serde.rs/">serde</a></li>
<li>geo-spatial processing: <a href="https://georust.org/">GeoRust</a> - esp. <a href="https://docs.rs/geo/latest/geo/">geo</a> and [gdal](https://docs.rs/gdal/latest/gdal/,
<a href="https://nalgebra.org/">nalgebra</a>)</li>
<li>physical computation: <a href="https://docs.rs/uom/latest/uom/">uom</a></li>
<li>asynchronous programming: <a href="https://tokio.rs/">Tokio</a></li>
</ul>
<p>These are defined as workspace dependencies (in the <code>odin-rs</code> <code>Cargo.toml</code>) to make sure versions are compatible
across all <code>odin-rs</code> sub crates.</p>
<p>The client code (browser scripts/modules) in <code>odin-rs</code> does not strictly follow the rule of using existing libraries. This code runs in many
different environments (browsers, operating systems, hardware) and has to be loaded over the network so we have to minimize
the amount of required code by adhering to what we strictly need. This also means to limit the client code to user interface
related functions and performing as much data processing as possible on the server side.</p>
<p>Where a separation is not entirely possible (e.g. to serve client library specific data/code) respective <code>odin-rs</code> sub-crates have to
be very limited in scope and purpose, and are not allowed to be a dependency for non-client dependent ones (see [<code>odin_cesium</code>] example).</p>
<p>That said there are (a) readily available standard browser APIs we have to use in order to be platform/browser independent, and (b) complex
geospatial display libraries that cannot be re-implemented in <code>odin-rs</code>. The former is the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">Document Object Model (DOM)</a> that is supported by contemporary browsers. The latter is the virtual globe display for which we use <a href="https://cesium.com/platform/cesiumjs/">CesiumJS</a>. This is a serious 3rd party dependency and hence extra care has to be
taken to not let it proliferate into the server. This is achieved with the following principle.</p>
<h2 id="separate-server--and-client--side-code"><a class="header" href="#separate-server--and-client--side-code">Separate server- and client- side code</a></h2>
<p>The primary purpose of the server is to import and process external data, and then serve it in a timely manner to connected clients.
The client code should only be concerned about visualization and user interface.</p>
<p>To that end communication between the two is using standard protocols and data formats, namely <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">HTTP</a> and <a href="https://www.json.org/json-en.html">JSON</a> over <a href="https://en.wikipedia.org/wiki/WebSocket">websockets</a>. The ideal
is to be able to re-implement each side without affecting the other.</p>
<h2 id="use-the-rust-type-system-to-enforce-correct-semantics"><a class="header" href="#use-the-rust-type-system-to-enforce-correct-semantics">Use the Rust type system to enforce correct semantics</a></h2>
<p>Many domain-specific 3rd party Rust libraries do abstract the memory type of variables (e.g. <code>f64</code>) but do little to enforce
compatible units of measure (e.g. SI vs. Imperial). As a simple example, the correct use of angles entails</p>
<ul>
<li>memory type (e.g. <code>f64</code>)</li>
<li>units (degrees or radians)</li>
<li>semantics (e.g. use as latitude or longitude)</li>
</ul>
<p>Again we can use the Rust type system to our advantage. By means of using <a href="https://docs.rs/uom/latest/uom/">uom</a> types (such as
<code>Length</code> based on SI and <code>f64</code>), and/or by using the <a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html"><em>NewType</em> pattern</a> and overloadable Rust <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> traits we can add specific types that catch most potential errors at compile time without introducing runtime overhead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-crates"><a class="header" href="#system-crates">System Crates</a></h1>
<p>As the name implies ODIN <em>system crates</em> provide functionality that is not directly associated to a specific application domain such as weather or even the general topic of disaster management. Most of them can be used for non-ODIN applications.</p>
<p>ODIN system crates can be divided into the following categories:</p>
<h2 id="odin-development"><a class="header" href="#odin-development">ODIN development</a></h2>
<ul>
<li><a href="odin_build/odin_build.html">odin_build</a> - this crate is a build- and runtime dependency for other ODIN crates. It
provides the mechanism to build stand-alone applications that do not rely on separate resource files</li>
<li><a href="odin_macro/odin_macro.html">odin_macro</a> - this is collection of macros that implement domain specific languages
used especially by <code>odin_actor</code></li>
</ul>
<h2 id="cross-cutting-functions"><a class="header" href="#cross-cutting-functions">cross-cutting functions</a></h2>
<ul>
<li><a href="odin_common/odin_common.html">odin_common</a> - this is primarily a collection of cross-cutting functions that extend
the Rust standard libraries and provide some basic capabilities such as admin notification</li>
<li><a href="odin_gdal/odin_gdal.html">odin_gdal</a> - a crate that wraps and extends the <a href="https://gdal.org">GDAL</a> library for geo-spatial
data sets and images</li>
<li><a href="odin_dem/odin_dem.html">odin_dem</a> - a simple digital elevation model based on <a href="https://gdal.org/en/latest/drivers/raster/vrt.html">GDAL VRT</a></li>
</ul>
<h2 id="architectural-crates"><a class="header" href="#architectural-crates">architectural crates</a></h2>
<ul>
<li><a href="odin_actor/odin_actor.html">odin_actor</a> - this crate implements a full actor system and is the architectural
basis for most ODIN app crates</li>
<li><a href="odin_action/odin_action.html">odin_action</a> - a crate that provides generic callbacks (used primarily to make
actors inter-operable)</li>
<li><a href="odin_job/odin_job.html">odin_job</a> - general system-global scheduling</li>
<li><a href="odin_server/odin_server.html">odin_server</a> - this crate provides the building blocks to construct web server actors</li>
<li><a href="odin_share/odin_share.html">odin_share</a> - crate that provides infrastructure to share data between services and users</li>
</ul>
<h2 id="client-library-support"><a class="header" href="#client-library-support">client library support</a></h2>
<ul>
<li><a href="odin_cesium/odin_cesium.html">odin_cesium</a> - this crate provides assets for client side virtual globe rendering with
<a href="https://cesium.com/platform/cesiumjs">CesiumJS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_build"><a class="header" href="#odin_build">odin_build</a></h1>
<p><code>odin_build</code> is a library crate that is used in a dual role both for utility functions called by ODIN crate specific
<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripts</a> and at application runtime to locate resources and global directories.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>The primary use of ODIN is to create servers - either interactive web-servers or edge-servers used by other applications. To that end ODIN servers support four general categories of data:</p>
<ol>
<li>configs - essential runtime invariant configuration data (e.g. URIs and user credentials for external servers)</li>
<li>assets - essential runtime invariant data that is served/used by ODIN (e.g. CSS and Javascript modules for web servers)</li>
<li>data - global persistent data for ODIN applications that can change independently of the ODIN application using them</li>
<li>cache - global transient data for ODIN applications (e.g. cached responses from proxied servers)</li>
</ol>
<p>Configs and assets are essential <strong>resources</strong>, i.e. applications can rely on their existence (but not their values). For <code>data</code> and <code>cache</code> we only guarantee that respective directories exist at runtime - the use of those directories is up to individual applications.</p>
<p>Common to all categories is that such data can change independently of the ODIN Rust sources using them and hence do need a consistent, well defined lookup mechanism used throughout all ODIN applications. That mechanism is implemented in <code>odin_build</code>, mostly through four functions:</p>
<ul>
<li><code>❬crate❭::load_config&lt;C&gt; (file_name: &amp;str)-&gt;Result&lt;C&gt;</code> (<code>C</code> being the type of the requested, deserializable config struct)</li>
<li><code>❬crate❭::load_asset (file_name: &amp;str)-&gt;Result&lt;Bytes&gt;</code></li>
<li><code>odin_build::data_dir()-&gt;&amp;'static PathBuf</code></li>
<li><code>odin_build::cache_dir()-&gt;&amp;'static PathBuf</code></li>
</ul>
<p>The reason why the first two functions reside in the crates defining respective resources is that we also support stand-alone ODIN applications that can be distributed as single executable files, without the need to install (potentially sensitive) resource files (e.g. containing user authentication for 3rd party servers). This seems to be incompatible with that resource values can be changed independently of ODIN Rust sources.</p>
<p>To reconcile the two requirements we support a general build mode for ODIN applications that takes (at build-time) resource files and generates statically linked Rust sources from them. Generating source fragments for such <strong>embedded resources</strong> is done by build scripts utilizing functions provided by <code>odin_build</code>. The data flow is as follows:</p>
<pre><code>      ┌────────────────┐                                                            
      │crate odin_build│                                                            
      └──────┬─────────┘                                                            
             │          ┌─────────────────────┐                                     
             │          │ crate my_crate      │        [cargo]                            
             │          │                     │      $OUT_DIR (../target/❬mode❭/build/A-../out/)                                  
             │          │   Cargo.toml (0)    │    ┌─────────────┐                  
             ╰──────────┼─► build.rs  ───(1)──┼───►│ config_data │                  
                        │   src/              │    └┬───▲──▲─────┘                  
                        │  ╭─ lib.rs ◄───(2)──┼─────╯   ╎  ╎
                        │  │  ...             │         ╎  ╎
                        │ (3) bin/            │         ╎  ╎
                        │  ╰─►  my_app.rs     │         ╎  ╎          [user]
                        │     ...             │         ╎  ╎        $ODIN_ROOT/         
                        │   configs/ ╶╶╶╶╶╶╶╶╶┼╶╶╶╶╶╶╶╶╶╯  ╰╶╶╶╶╶╶     configs/          
                        │     my_config.ron   │   internal or external    my_crate/             
                        └─────────────────────┘         resource             my_config.ron

</code></pre>
<p>This involves several steps:</p>
<h3 id="0-declaration-of-embeddable-resources-in-cargotoml-manifest-of-owning-crates"><a class="header" href="#0-declaration-of-embeddable-resources-in-cargotoml-manifest-of-owning-crates">(0) declaration of embeddable resources in Cargo.toml manifest of owning crates</a></h3>
<p>The first step is to specify package meta data for embeddable resource files in the crates owning them (henceforth called <strong>resource crate</strong>):</p>
<pre><code class="language-toml">[[bin]]
name = "my_app"

[package.metadata.odin_configs]
my_config = { file="my_config.ron" }
...
[package.metadata.odin_assets]
my_asset = { file="my_asset.js", bins=["my_app"] }

[features]
embedded_resources = []
...
</code></pre>
<p>The <code>embedded_resource</code> feature should be transitive - if the resource crate in turn depends on other ODIN resource crates we have to pass-down the feature like so: <code>embedded_resources = ["❬other-odin-crate❭/embedded_resources" …]</code></p>
<h3 id="1-creation-of-embedded-resource-data"><a class="header" href="#1-creation-of-embedded-resource-data">(1) creation of embedded resource data</a></h3>
<p>This step uses a build script of the resource crate to generate embedded resource code by calling functions from <code>odin_built</code>, showing its role as a build-time library crate:</p>
<pre><code class="language-rs"> use odin_build;

 fn main () {
     odin_build::init_build();
     odin_build::create_config_data().expect("failed to generate config_data");
     odin_build::create_asset_data().expect("failed to generate asset_data");
 }
</code></pre>
<p>Note that using embedded resources requires the <code>embedded_resources</code> <a href="https://doc.rust-lang.org/cargo/reference/features.html">feature</a> when building resource crates since it involves conditional compilation (more specifically feature-gated <code>import!(❬embedded-resource-fragment❭)</code> calls).</p>
<p>ODIN stores all embedded resource data in compressed format. Depending on resource file type data might be minified before compression.</p>
<h3 id="2-declaration-of-resource-accessor-functions-in-resource-crates"><a class="header" href="#2-declaration-of-resource-accessor-functions-in-resource-crates">(2) declaration of resource accessor functions in resource crates</a></h3>
<p>At application runtime we use two macros from <code>odin_build</code> that expand into crate-specific public <code>load_config(…)</code> and <code>load_asset(…)</code> functions mentioned above.</p>
<pre><code class="language-rs">use odin_build::{define_load_config,define_load_asset};

define_load_config!{}
define_load_asset!{}
...
</code></pre>
<p>If the application was built with the <code>embedded_resources</code> feature the expanded <code>load_config(…)</code> and <code>load_asset(…)</code> functions conditionally import the resource code fragments.</p>
<h3 id="3-use-of-resources"><a class="header" href="#3-use-of-resources">(3) use of resources</a></h3>
<p>Using resource values at runtime is done through calling the expanded <code>load_config(…)</code> and <code>load_asset(…)</code> functions, which only require abstract resource filenames (not their location). The application source code is fully independent of the build mode:</p>
<pre><code class="language-rs">fn main() {
    odin_build::set_bin_context();
    ...
    let config: MyConfig = load_config("my_config.ron")?;
    ...
    let asset: &amp;Vec&lt;u8&gt; = load_asset("my_asset.js")?;
}
</code></pre>
<h2 id="resource-lookup"><a class="header" href="#resource-lookup">Resource Lookup</a></h2>
<p>We use the same algorithm for each individual resource file lookup during build-time and application run-time. This algorithm is implemented in <code>odin_build::find_resource_file(…)</code> and based on two main directory types of ODIN:</p>
<ul>
<li><strong>root directories</strong></li>
<li><strong>workspace directories</strong></li>
</ul>
<h3 id="odin-root-dir"><a class="header" href="#odin-root-dir">ODIN Root Dir</a></h3>
<p>A <strong>root-dir</strong> is a directory that contains resource data that is kept outside of the source repository. ODIN applications are not supposed to rely on anything outside their root-dir but the user can control which root-dir to use (there can be several of them, e.g. for development and production)</p>
<p>We detect the root-dir to use in the following order:</p>
<ol>
<li>whatever the optional environment variable <code>ODIN_ROOT</code> is set to</li>
<li>the parent of a workspace dir <strong>iff</strong> the current dir is (within) an ODIN workspace and this parent contains any of <code>cache/</code>,
<code>data/</code>, <code>configs/</code> or <code>assets/</code> sub-dirs. This is to support a self-contained directory structure during development, not
requiring any environment variables</li>
<li>a <code>$HOME/.odin/</code> otherwise - this is the normal production mode</li>
</ol>
<p>An ODIN <strong>root-dir</strong> can optionally contain other sub-directories such as the ODIN <strong>workspace-dir</strong> mentioned below.</p>
<pre><code>.
└── ❬odin-root-dir❭/
    ├── configs/                        read-only data deserialized into config structs
    │   ├── ❬resource-crate❭/
    │   │   ├── ❬resource-file❭
    │   │   └── ...
    │   └── ❬bin-crate❭/
    │       └── ❬resource-crate❭/
    │           ├── ❬resource-file❭     bin specific override
    │           └── ...
    ├── assets/                         read-only binary data served by ODIN app
    │   ├── ❬resource-crate❭/...
    │   └── ❬bin-crate❭/...
    │
    ├── data/                           persistent runtime data for ODIN apps
    │   └── ...
    │
    ├── cache/                          transient runtime data for ODIN apps
    │   └── ...
    │
    └── ... (e.g. odin-rs/)             optional dirs (ODIN workspace-dir etc.)
</code></pre>
<h3 id="odin-workspace-dir"><a class="header" href="#odin-workspace-dir">ODIN Workspace Dir</a></h3>
<p>The <strong>workspace-dir</strong> is the top directory of an ODIN source repository, i.e. the directory into which the <code>odin-rs</code> Github repository was cloned. While the primary content of a <strong>workspace-dir</strong> are the ODIN crate sources, such crates <em>can</em> contain
configs and assets in case those should be kept within the source repository. This is typically the case for crates that serve/communicate with Javascript module assets - here we want to make sure asset and related ODIN Rust code are kept together.</p>
<p>The <strong>workspace-dir</strong> is the topmost dir that holds a Cargo.toml, starting from the current dir.</p>
<p>A <strong>workspace-dir</strong> follows the normal cargo convention but adds optional <code>configs/</code> and <code>assets/</code> sub-directories to respective workspace crates:</p>
<pre><code>.
└── ❬odin-workspace-dir❭/
    ├── Cargo.toml                     ODIN workspace definition    
    ├── ❬crate-dir❭/
    │   ├── Cargo.toml                 including odin_configs and odin_assets metadata
    │   ├── build.rs                   calling odin_build functions
    │   ├── src/...                    normal Cargo dir structure
    │   │
    │   ├── configs/                   (optional) in-repo config resources for this crate
    │   │   ├── ❬resource-file❭
    │   │   └── ...
    │   └── assets/                    (optional) in-repo asset resources for this crate
    │       ├── ❬resource-file❭
    │       └── ...
    ├── ...                            other ODIN crates
    └── target/...                     build artifacts   
</code></pre>
<p>With those directory types we can now define the resource file lookup algorithm:</p>
<h3 id="file-lookup-algorithm"><a class="header" href="#file-lookup-algorithm">File Lookup Algorithm</a></h3>
<p>For each given tuple</p>
<ul>
<li>root-dir (ODIN_HOME | workspace-parent | ~/.odin)</li>
<li>(optional) workspace-dir</li>
<li>resource type ("configs" or "assets"),</li>
<li>resource filename,</li>
<li>resource crate and</li>
<li>(optional) bin name + crate</li>
</ul>
<p>check in the following order:</p>
<ol>
<li>root-dir / resource-type / bin-crate / bin-name / resource-crate / filename</li>
<li>root-dir / resource-type / resource-crate / filename</li>
<li>workspace-dir / resource-type / bin-crate / bin-name / resource-crate / filename</li>
<li>workspace-dir / resource-type / resource-crate / filename</li>
</ol>
<p>This is implemented in the <code>odin_build::find_resource_file(…)</code> function which returns an <code>Option&lt;PathBuf&gt;</code>.</p>
<h3 id="runtime-resource-lookup-algorithm"><a class="header" href="#runtime-resource-lookup-algorithm">Runtime Resource Lookup Algorithm</a></h3>
<p>At application runtime we optionally extend the above file system lookup mechanism by checking for an embedded resource within the resource-crate <strong>iff</strong> no file was found with the above algorithm.</p>
<p>By setting a runtime environment variable <code>ODIN_EMBEDDED_ONLY=true</code> we can force the lookup to only consider embedded resources (i.e. to ignore resource files in the file system).</p>
<p>This lookup is performed for each resource separately, i.e. it is not just possible but even usual to have resources to reside in different locations (root dir and workspace dir). Typically only configs with user settings or credentials are kept outside the repository whereas assets are kept within. The main exception would be development/test environments.</p>
<h2 id="odin-environment-variables"><a class="header" href="#odin-environment-variables">ODIN Environment Variables</a></h2>
<p>At runtime, ODIN applications use the following optional environment variables:</p>
<ul>
<li><code>ODIN_HOME</code> - the ODIN root directory to use</li>
<li><code>ODIN_EMBEDDED_ONLY</code> - use only embedded configs, no file system lookup</li>
<li><code>ODIN_BIN_SUFFIX</code> - optional suffix for binary name (can be used to differentiate multiple concurrent
<code>ODIN_BIN_NAME</code>/<code>CARGO_BIN_NAME</code> processes)</li>
<li><code>ODIN_RELOAD_ASSETS</code> - if set asset lookup is not cached (useful for debugging javascript modules)</li>
</ul>
<p>At build-time, ODIN uses the following environment variables to provide build script input</p>
<ul>
<li><code>ODIN_BIN_CRATE</code> - set manually or by ODIN build tool</li>
<li><code>ODIN_BIN_NAME</code> - set manually or by ODIN build tool</li>
<li><code>ODIN_EMBED_RESOURCES</code> - set manually or by ODIN build tool</li>
<li><code>OUT_DIR</code> - automatically set by cargo</li>
<li><code>CARGO_PKG_NAME</code> - automatically set by cargo</li>
<li><code>CARGO_BIN_NAME</code> - automatically set by cargo for bin target</li>
</ul>
<h2 id="odin-build-tools"><a class="header" href="#odin-build-tools">ODIN build tools</a></h2>
<p>To further simplify building applications with embedded resources <code>odin_build</code> includes a tool that automates setting required environment variables, calling cargo and reporting embedded files:</p>
<pre><code>bob [--embed] [--root ❬dir❭] [❬cargo-opts❭...] ❬bin-name❭
  --embed      : build binary with embedded resources
  --root ❬dir❭ : set ODIN root dir to embed resources from
</code></pre>
<p>Using this tool is optional. ODIN applications can be built/run through normal cargo invocation but in this case resources are not embedded without manually setting the above <code>ODIN_..</code> build-time environment variables and the <code>embedded_resources</code> feature.</p>
<p>Although provided by the <code>odin_common</code> crate the <code>duplicate_dir</code> command line tool can be used to duplicate nested <code>ODIN_ROOT</code> directory trees. Use
the <code>--link-files</code> option to create root dirs that only override some config/asset files and otherwise link to an existing root dir:</p>
<pre><code>duplicate_dir [FLAGS] [OPTIONS] &lt;source-dir&gt; &lt;target-dir&gt;

FLAGS:
    -h, --help          Prints help information
    -l, --link-files    only use symbolic (soft) links for files
    -V, --version       Prints version information

OPTIONS:
    -e, --exclude &lt;exclude&gt;...    exclude file or directory matching glob

ARGS:
    &lt;source-dir&gt;    root directory to duplicate
    &lt;target-dir&gt;    directory to duplicate to (will be created/overwritten)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_action"><a class="header" href="#odin_action">odin_action</a></h1>
<p>The <code>odin_action</code> crate provides several variants of <strong>action</strong> types together with macros to define and instantiate ad
hoc actions. The generic <strong>action</strong> construct represents application specific objects that encapsulate async
computations, to be executed by an <em>action owner</em> that can invoke such computations with its own data (e.g. sending
messages in actor systems that are built from its data).</p>
<p>The primary purpose of actions is to build re-usable action owners that do not have to be aware of in which
application context they are used. All the owner has to know is when to execute an action and what of its own data
it should provide as an argument.</p>
<p>In a synchronous world this is often described as a "callback".</p>
<p>The basis for this are "Action" traits with a single <code>async fn execute(&amp;self,data..)-&gt;Result&lt;()&gt;</code> method. Instances of
these traits are normally created where we assemble an application (e.g. in <code>main()</code>), i.e. where we know all the
relevant interaction types. They are then passed either as generic type constructor arguments or later-on (at runtime)
as trait objects to their owners, to be invoked either on-demand or when the owner state changes.</p>
<p>Technically, actions represent a special case of async closures in which capture is done by either <code>Copy</code>
or <code>Clone</code>. Reference capture is not useful here since actions are executed within another task, without any
lifetime relationship to the context in which the actions were created.</p>
<p>We support the following variants:</p>
<ul>
<li>[<code>DataAction&lt;T&gt;</code>] trait and ['data_action`] macro</li>
<li>[<code>DataRefAction&lt;T&gt;</code>] trait and ['dataref_action`] macro</li>
<li>[<code>BiDataAction&lt;T,A&gt;</code>] trait and [<code>bi_data_action</code>] macro</li>
<li>[<code>BiDataRefAction&lt;T,A&gt;</code>] trait and [<code>bi_dataref_action</code>] macro</li>
<li>[<code>DynDataAction&lt;T&gt;</code>] type and ['dyn_data_action`] macro</li>
<li>[<code>DynDataRefAction&lt;T&gt;</code>] type and ['dyn_dataref_action`] macro</li>
</ul>
<p>The difference between <code>..DataAction</code> and <code>..DataRefAction</code> is how the owner data is passed into the trait's
<code>execute(..)</code> function: as a moved value (<code>execute(&amp;self,data:T)</code>) or as a reference (<code>execute(&amp;self,data:&amp;T)</code>).</p>
<p>The <code>Bi..Action&lt;T,B&gt;</code> traits have <code>execute(..)</code> functions that take two arguments (of potentially different types). This is
helpful in a context where the action body requires both owner state (<code>T</code>) and information that was passed to the
owner (<code>B</code>) in the request that triggers the action execution and can avoid the runtime overhead of async action trait
objects (requiring <code>Pin&lt;Box&lt;dyn Future ..&gt;&gt;</code> execute return values). The limitation of bi-actions is that both
action owner and requester have to know the bi_data type (<code>B</code>), which therefore tends to be unspecific (e.g. <code>String</code>).
This in turn makes bi-actions more susceptible to mis-interpretation and therefore the action owner should only use
<code>B</code> as a pass-through argument and not generating it (which would require the owner knows what potential requesters
expect semantically).</p>
<p><code>Dyn..Action</code> types (which represent trait objects) are used in two different contexts:</p>
<ul>
<li>to execute actions that were received as function arguments (e.g. through async messages)</li>
<li>to store such actions in homogenous <code>Dyn..ActionList</code> containers for later execution</li>
</ul>
<p>The <code>Dyn..ActionList</code> containers use an additional <code>ignore_err: bool</code> argument in their <code>execute(..)</code> methods
that specifies if the execution should shortcut upon encountering error results when executing its stored actions
or if return values of stored actions should be ignored.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyActor { ...
    data: MyData, 
    actions: DynDataActionList&lt;MyData&gt;
}
...
impl MyActor {
    async fn exec (&amp;self, da: DynDataAction&lt;MyData&gt;) { 
        da.execute(&amp;self.data).await;
    }

    fn store (&amp;mut self, da: DynDataAction&lt;MyData&gt; ) { 
        .. self actions.push( da) ..
    }
    ... self.actions.execute(&amp;self.data, ignore_err).await ...
}
<span class="boring">}</span></code></pre></pre>
<p>Note that <code>Dyn..Action</code> instances do have runtime overhead (allocation) per <code>execute(..)</code> call.</p>
<p>Since actions are typically one-of-a-kind types we provide macros for all the above variants that both define the type
and return an instance of this type. Those macros all follow the same pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//--- system construction site:
let v1: String = ...
let v2: u64 = ...
let action = data_action!{ 
    let v1: String = v1.clone(), 
    let v2: u64 = v2 =&gt; 
    |data: Foo| {
        println!("action executed with arg {:?} and captures v1={}, v2={}", data, v1, v2);
    Ok(())
    }
};
let actor = MyActor::new(..action..);
...
//--- generic MyActor implementation:
struct MyActor&lt;A&gt; where A: DataAction&lt;Foo&gt; { ... action: A ... }
impl&lt;A&gt; MyActor&lt;A&gt; where A: DataAction&lt;Foo&gt; {
  ... let data = Foo{..}
  ... self.action.execute(data).await ...
}
<span class="boring">}</span></code></pre></pre>
<p>the example above expands into a block with three different parts: capture struct definition, action trait impl and capture struct instantiation</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    struct SomeDataAction { v1: String, v2: u64 }

    impl DataAction&lt;Foo&gt; for SomeDataAction {
         async fn execute (&amp;self, data: Foo)-&gt;std::result::Result&lt;(),OdinActionError&gt; {
             let v1 = &amp;self.v1; let v2 = &amp;self.v2;
             println!(...);
             Ok(())
         }
    }

    SomeDataAction{ v1: v1.clone(), v2 }
}
<span class="boring">}</span></code></pre></pre>
<p>The action bodies are expressions that have to return a <code>Result&lt;(),OdinActionError&gt;</code> so that we can coerce errors in crates using
<code>odin_action</code>. This means that we can use the <code>?</code> operator to shortcut within action bodies, but we have to map respective results
by means of our <code>map_action_err()</code> function and make sure to use <code>action_ok()</code> instead of explicit <code>Ok(())</code> (to tell the compiler
what <code>Result&lt;T,E&gt;</code> it refers to):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute_some_result(...)-&gt;Result&lt;(),SomeError&gt; {...}
...
data_action!( ... =&gt; |data: MyData| {
    ...
    map_action_err( compute_some_result(...) )?
    ...
    action_ok()
})
<span class="boring">}</span></code></pre></pre>
<p>For actions that end in a result no mapping is required (<code>map_action_err(..)</code> is automatically added by the macro expansion):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>data_action!( ... =&gt; |data: MyData| {
    ...
    compute_some_result(...)
})
<span class="boring">}</span></code></pre></pre>
<p>[<code>OdinActionError</code>] instances can be created from anything that implements [<code>ToString</code>]`</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_actor"><a class="header" href="#odin_actor">odin_actor</a></h1>
<p>The <code>odin_actor</code> crate provides an implementation of a typed <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a>
that serves as the common basis for ODIN applications.</p>
<p><em>Actors</em> are objects that execute concurrently and only communicate through asynchronous <em>Messages</em>. Actors do not share their internal <em>State</em> and are only represented to the outside by <em>ActorHandles</em>. The only operation supported by ActorHandles is to send messages to the actor, which are then queued in an (actor internal) <em>Mailbox</em> and processed by the actor in the order in which they were received. In reaction to received messages actors can send messages or mutate their internal state:</p>
<pre><code>         ╭──────╮
   ─────▶︎│Handle│─────x:X──╮ Message
       ┌─┴──────┴──────────│───┐
       │ Actor   State   ┌─▼─┐ │
       │          ▲      ├─:─┤ MailBox
       │          │      └───┘ │
       │          ▼        │   │
       │   receive(m) ◀︎────╯   │
       │     match m           │
       │       X =&gt; process_x  │
       │    ...          ───────────▶︎ send messages to other actors
       └───────────────────────┘ 
</code></pre>
<p>From a Rust perspective this is a library that implements actors as async tasks that process input received through
actor-owned channels and encapsulate actor specific state that is not visible to the outside. It is an architectural
abstraction layer on top of async runtimes (such as <a href="https://tokio.rs/">tokio</a>).</p>
<p>In <code>odin_actor</code> we map the message interface of an actor to an <code>enum</code> containing variants for all message types
understood by this actor (variants can be anything that satisfies Rust's <code>Send</code> trait). The actor state is a user
defined <code>struct</code> containint the data that is owned by this actor. Actor behavior defined as a <code>trait</code> impl that
consists of a single <code>receive</code> function that matches the variants of the actor message enum to user defined expressions.</p>
<p>Please refer to the respective chapter in the <code>odin_book</code> for more details.</p>
<p>The <code>odin_actor</code> crate mostly provides a set of macros that implement a DSL for defining and instantiating these
actor components, namely</p>
<ul>
<li>[<code>define_actor_msg_set</code>] to define an enum for all messages understood by an actor</li>
<li>[<code>impl_actor</code>] to define the actor as a 3-tuple of actor state, actor message set and a <code>receive</code> function that provides
the (possibly state dependent) behavior for each input message (such as sending messages to other actors)</li>
<li>[<code>spawn_actor</code>] to instantiate actors and start their message receiver tasks</li>
</ul>
<p>Here is the "hello world" example of <code>odin_actor</code>, consisting of a single Greeter actor:</p>
<pre><pre class="playground"><code class="language-rust">use tokio;
use odin_actor::prelude::*;

// define actor message set ①
#[derive(Debug)] pub struct Greet(&amp;'static str);
define_actor_msg_set! { pub GreeterMsg = Greet }

// define actor state ②
pub struct Greeter { name: &amp;'static str }

// define the actor tuple (incl. behavior) ③
impl_actor! { match msg for Actor&lt;Greeter,GreeterMsg&gt; as
    Greet =&gt; term! { println!("{} sends greetings to {}", self.name, msg.0); }
}

// instantiate and run the actor system ④
#[tokio::main]
async fn main() -&gt;Result&lt;()&gt; {
    let mut actor_system = ActorSystem::new("greeter_app");

    let actor_handle = spawn_actor!( actor_system, "greeter", Greeter{name: "me"})?;
    actor_handle.send_msg( Greet("world")).await?;

    actor_system.process_requests().await?;

    Ok(())
}</code></pre></pre>
<p>This breaks down into the following four parts:</p>
<h3 id="①-define-actor-message-set"><a class="header" href="#①-define-actor-message-set">① define actor message set</a></h3>
<h3 id="②-define-actor-state"><a class="header" href="#②-define-actor-state">② define actor state</a></h3>
<h3 id="③-define-the-actor-tuple-incl-behavior"><a class="header" href="#③-define-the-actor-tuple-incl-behavior">③ define the actor tuple (incl. behavior)</a></h3>
<h3 id="④-instantiate-and-run-the-actor-system"><a class="header" href="#④-instantiate-and-run-the-actor-system">④ instantiate and run the actor system</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-actor-programming-model"><a class="header" href="#the-actor-programming-model">The Actor Programming Model</a></h1>
<p>Actors represent a concurrency programmming model that avoids shared memory between concurrent (and possibly parallel)
executions by means of message passing. Since its introduction in [^Hewitt73] it has been the subject of extensive
formalization but the essence is that</p>
<p class="standout">actors are concurrently executing objects that only communicate through messages, without sharing state</p>
<p>In addition, existing actor implementations also ensure that messages received by an actor are processed sequentially,
which basically allows to treat an actor implementation as sequential code. This significantly reduces the concurrency
related complexity of systems that use actors as their primary building blocks.</p>
<p>The Actor programming model as used by <code>odin_actor</code> revolves around five components:</p>
<img class="mono right" src="odin_actor/../img/actors-mono.svg" width="35%"/>
<ul>
<li>an <strong>ActorSystem</strong> that instantiates and manages actors</li>
<li>the <strong>Actors</strong> themselves as the units of concurrent execution</li>
<li><strong>ActorHandles</strong> as the public-facing actor component</li>
<li><strong>actor mailboxes</strong> that represent the (internal) message queues of actors</li>
<li><strong>actor state</strong> as the mutable, internal memory of an actor</li>
<li>a <strong>receive(msg)</strong> function that defines how the actor processes received messages</li>
</ul>
<p><strong>ActorSystems</strong> instantiate and monitor actors. In concrete implementations they include some scheduler that picks
runnable actors (with pending messages) and maps them to kernel threads. They can also be used to manage global
resources (such as job schedulers) and perform actor synchronization (i.e. implement <code>ActorSystem</code> specific actor
state models)</p>
<p><strong>Actors</strong> are the concurrently executing entities. An actor aggregates a usually invisible <strong><code>mailbox</code></strong> (message queue),
an <strong>actor state</strong> that holds the (mutable) actor-specific data and a <strong><code>receive(msg)</code></strong> message handler function that can
in response to received messages</p>
<ul>
<li>mutate the actor state</li>
<li>create other actors</li>
<li>send messages to other actors</li>
</ul>
<p>It should be noted that <strong>Actors</strong> are an abstract concept - concrete ActorSystem implementations have considerable
leeway to implement them. They can use message queues and actor state outside of physical actor objects. Actors
can even be implemented as "behavior" function objects that pass in the state as a message handler argument, and use the
message handler return value to set the next behavior and/or state.</p>
<p><strong>ActorHandles</strong> represent the visible reference of an actor towards other actors and the actor system. The role of
an <strong>ActorHandle</strong> is to allow sending messages to the associated actor without exposing its internal state or directly
affecting its lifetime.</p>
<p>The original actor programming model is abstract. It does not concern itself with implementation specifics such as
type safety, e.g. to statically check that we can only send messages to actors that can handle them. However, those
programming language specific aspects can have a profound impact on genericity and safety of actor system frameworks
(e.g. to ensure that we do not leak actor state through references passed in messages).</p>
<p>Concrete implementations should also specify</p>
<ul>
<li>mailbox/send semantics (unbounded -&gt; non-blocking send, bounded -&gt; blocking when receiver queue is full)</li>
<li>message processing order (e.g. <em>sequential-per-sender</em>)</li>
</ul>
<p>Especially the first topic is relevant to address potential <em>back-pressure</em> in actor systems (slow receivers blocking
fast senders).</p>
<p>[^Hewitt73]	: Carl Hewitt; Peter Bishop; Richard Steiger (1973). "A Universal Modular Actor Formalism for Artificial Intelligence". IJCAI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-design"><a class="header" href="#basic-design">Basic Design</a></h1>
<p>This chapter describes how the general actor constructs introduced in <a href="odin_actor/actor_basics.html">actor_basics</a> are implemented in <code>odin_actor</code>,
which reflects our major design choices:</p>
<ul>
<li>map each actor into a dedicated <a href="https://rust-lang.github.io/async-book/">async task</a> that owns the actor state</li>
<li>use an actor specific enum type to define the set of messages that can be sent to/are processed by this actor
(each message type is wrapped into a tuple struct variant of this enum)</li>
<li>use bounded <a href="https://doc.rust-lang.org/rust-by-example/std_misc/channels.html">multi-producer/single-consumer (MPSC) channels</a>
of this message set enum to implement actor mailboxes</li>
<li>wrap the sender part of the channel into a (cloneable) actor handle and move the receiver part and the actor state into
the task function, which loops to process received messages</li>
<li>use normal enum matching to dispatch messages from within the actor task</li>
<li>use the actor handle to send messages to the associated actor</li>
</ul>
<p>This ensures our basic requirements:</p>
<ul>
<li>actor message interfaces can be checked at compile time - we can only send messages to actors who process them, and
each actor processes all of the message types in its interface</li>
<li>actor state cannot accidentally leak from within its task (neither during construction nor while sending messages)</li>
<li>actors can process concurrently (and - depending on async runtime and hardware - in parallel)</li>
<li>message processing back pressure is propagated (bounded channel write blocks until receiver is ready), the system related
memory per actor is bounded (no out-of-memory conditions because of "hung" actors)</li>
</ul>
<p>The remainder of this page looks at each of the actor elements: messages, mailboxes, actors (handles and state) and actor systems.</p>
<h2 id="messages-and-actor-message-sets"><a class="header" href="#messages-and-actor-message-sets">Messages and Actor Message Sets</a></h2>
<p>Messages are ordinary structs, they do not require any <code>odin_actor</code> specific overhead other than that they for obvious reasons
have to be <code>Send</code> and have to implement <code>Debug</code> (<code>odin_actor</code> requirement to support debug/logging).</p>
<p>The <code>odin_actor</code> crate does define a number of <em>system messages</em> for lifetime control and monitoring purposes (<code>_Start_</code>,
<code>_Pause_</code>, <code>_Resume_</code>, <code>_Timer_</code>, <code>_Exec_</code>, <code>_Ping_</code>, <code>_Terminate_</code>). Those messages do not have to be handled explicitly by actors (although
they can, should the actor require specific actions). System messages can be sent to any actor.</p>
<p><em>Message sets</em> are the complete message interfaces of their associated actors. They are implemented as <code>enums</code> since we
want to be able to statically (at compile time) check that</p>
<ul>
<li>an actor processes all message types in its interface (no "forgotten" messages)</li>
<li>we can only send messages to actors who have this message type in their interface</li>
</ul>
<p>Other than for actor definition message set enums are mostly transparent, which means they need <code>From&lt;msg-type&gt;</code> impls for all their
variants. Message sets have to include the system messages mentioned above. Since this would be tedious to define explicitly we provide
the <code>define_actor_msg_set!(..)</code> macro that can be used like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use odin_actor::prelude::*;

#[derive(Debug)] struct MsgA(usize);
#[derive(Debug)] struct MsgB(usize);

define_actor_msg_set! { MyActorMsg = MsgA | MsgB }
...
<span class="boring">}</span></code></pre></pre>
<p>This gets expanded to an enum type with <code>From&lt;T&gt;</code> impls for each of its variants:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
enum MyActorMsg {
    MsgA(MsgA),
    MsgB(MsgB)
}
impl From&lt;MsgA&gt; for MyActorMsg {...}
impl From&lt;MsgB&gt; for MyActorMsg {...}
...
<span class="boring">}</span></code></pre></pre>
<p>The macro also adds variants for the system messages so that we can send them to each actor.</p>
<p>Apart from automatic <code>From&lt;..&gt;</code> impls the main operation performed on message set enums is matching their variants inside of
actor <code>receive()</code> functions. To avoid boilerplate and to make the code more readable we provide support matching on variant
types from within the <code>impl_actor! {..}</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl_actor! { match msg for Actor&lt;MyActor,MyActorMsg&gt; as
    MsgA =&gt; cont! { 
        // process msg: MyActorMsg::MsgA
    }
    ...
    _Start_ =&gt; cont! {
        // process msg: MyActorMsg::_Start_
    }
<span class="boring">}</span></code></pre></pre>
<p>However, Rust enum variants are <em>not</em> types, hence the framework automatically has to map type names (from the match arm patterns)
to variant identifiers, which requires name mangling in case of generic types and tuples. This name mangling is performed automatically
and uses similar valid unicode identifier characters (see <code>odin_macro</code> implementation) to ensure that compiler error messages are still
readable.</p>
<p>It should be noted that since we use <code>enums</code> to define message sets developers should be aware of the variant type sizes - Rust enums
are sized to accommodate the largest of their variants and mailboxes represent arrays of respective message set enums. Use <code>Arc&lt;MyLargeType&gt;</code> in case variants can get large.</p>
<h2 id="mailboxes"><a class="header" href="#mailboxes">Mailboxes</a></h2>
<p>Mailboxes are implemented as Rust <code>channels</code>, i.e. <code>odin_actor</code> does not provide its own type and uses (transparently) whatever the
configured channel implementation default to (e.g. <a href="https://docs.rs/flume/latest/flume/fn.bounded.html"><code>flume::bounded</code></a>). This is
controlled at build time by <code>odin_actor</code> features (currently <code>tokio_kanal</code> or <code>tokio_flume</code>).</p>
<p>The <code>odin_actor</code> crates uses bounded channels, i.e. we do not support dynamically sized mailboxes. The rationale is to use mailbox
bounds for back pressure control and to prevent out-of-memory errors at runtime. This also means we have to support three types
of message sends:</p>
<ul>
<li>async send (potentially blocking until space becomes available)</li>
<li>try_send (non-blocking but fails if mailbox is full)</li>
<li>timeout_send (async with a specified max timeout - in between the above two choices)</li>
</ul>
<h2 id="actorhandle"><a class="header" href="#actorhandle">ActorHandle</a></h2>
<p><code>ActorHandle</code> is a system provided struct with a type parameter that represents the actor message set type. This type
is used to define the sender-part of the actor mailbox (mpsc channel - see <a href="odin_actor/actor_impl.html#actor">Actor</a> section below), which in
turn is what makes our actor message interfaces type safe (at compile time).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ActorHandle &lt;M&gt; where M: MsgTypeConstraints {
    pub id: Arc&lt;String&gt;,
    hsys: Arc&lt;ActorSystemHandle&gt;,
    tx: MpscSender&lt;M&gt; // internal - this is channel specific
}
<span class="boring">}</span></code></pre></pre>
<p>Since <code>ActorHandle</code> is primarily used to send messages to the corresponding actor the main functions in its inherent impl are:</p>
<ul>
<li><code>async fn send_msg&lt;T&gt; (&amp;self, msg: T)-&gt;Result&lt;()&gt; where T: Into&lt;M&gt; {...}</code></li>
<li><code>async fn timeout_send_msg&lt;T&gt; (&amp;self, msg: T, to: Duration)-&gt;Result&lt;()&gt; where T: Into&lt;M&gt; {...}</code></li>
<li><code>pub fn try_send_msg&lt;T&gt; (&amp;self, msg:T)-&gt;Result&lt;()&gt; where T: Into&lt;M&gt; {...}</code></li>
</ul>
<p>Note that all are generic in the message type <code>T: Into&lt;M&gt;</code>, i.e. any type for which the respective actor message set <code>M</code>
has a <code>From</code> trait impl (which our <code>define_actor_msg_set!(..)</code> macro automatically generates).</p>
<p><code>ActorHandles</code> have one basic requirement - they have to be inexpensive to clone. For that reason we use <code>Arc&lt;T&gt;</code> references
to store the id (name) and the <code>ActorSystemHandle</code> of the respective actor.</p>
<p><code>ActorHandles</code> are not created explicitly - they are the return values of <code>spawn_actor!{..}</code> or <code>spawn_pre_actor!{..}</code> macro
calls.</p>
<p>The system also provides a <code>PreActorHandle&lt;M&gt;</code> struct that allows explicit construction in case we have cyclic dependencies
between actors. The sole purpose of <code>PreActorHandle</code> is to subsequently create <code>ActorHandles</code> from it. To that end it creates
and stores both sender and receiver parts of the actor task channel but it does not allow to use them - all its fields are private
and are just used as a temporary cache. The <code>spawn_pre_actor!{..}</code> macro is used to spawn actors from respective <code>PreActorHandles</code>.</p>
<h2 id="actor-state"><a class="header" href="#actor-state">Actor State</a></h2>
<p>Just like the for the message types <code>odin_actor</code> accepts any <code>struct</code> as actor state, without the need for any specific
fields or trait impls.</p>
<p>There usually is an associated inherent impl for such structs which defines the functional interface of the actor. A common
pattern is to use minimal code in the actor impl itself and just call actor state methods from the message match expressions
like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyActor {...}

impl MyActor {
    fn process_msg_a (&amp;mut self, msg: MsgA) {
        ...
    }
    ...
}

impl_actor! { match msg for Actor&lt;MyActor,MyActorMsg&gt; as
    MsgA =&gt; cont! { 
        self.process_msg_a( msg)
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="actor"><a class="header" href="#actor">Actor</a></h2>
<p>The <code>odin_actor</code> crate uses a single generic actor type</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Actor &lt;S,M&gt; where S: Send + 'static, M: MsgTypeConstraints {
    pub state: S,
    pub hself: ActorHandle&lt;M&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>where the type variable <code>S</code> represents the user defined actor state type and the type variable <code>M</code> represents the actor
message set type defined by a corresponding <code>define_actor_msg_set!(..)</code> invocation. The <code>Actor</code> type itself is mostly transparent,
usually it is only visible at the location where a concrete actor is defined with the <code>impl_actor! { ... }</code> macro.</p>
<p>To avoid boilerplate in the associated message matcher code <code>odin_actor</code> provides blanket <code>Deref</code> and <code>DerefMut</code> impls that
forward to the <code>state: S</code> field. For the most part, developers can treat actor and actor state synonymously.</p>
<p>One consequence of not having constraints on the actor state type and keeping system related data in the framework provided
<code>Actor&lt;S,M&gt;</code> struct is that we need to pass actor handles into inherent impl methods like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyActor {...}

impl MyActor {
    async fn send_something (&amp;mut self, hself: &amp;ActorHandle&lt;MyActorMsg&gt;) {
        hself.send_msg(...).await
    }
    ...
}

impl_actor! { match msg for Actor&lt;MyActor,MyActorMsg&gt; as
    ... =&gt; cont! { 
        self.send_something( &amp;self.hself).await
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>We define concrete <code>Actor</code> types by means of our <code>impl_actor!{..}</code> macro, which has the primary purpose of generating
a <code>ActorReceiver&lt;M&gt;</code> trait impl for the concrete <code>Actor</code> type. This trait defines the function</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn receive (&amp;mut self, msg: MsgType)-&gt; impl Future&lt;Output = ReceiveAction&gt; + Send
<span class="boring">}</span></code></pre></pre>
<p>which is our actor message dispatcher (a matcher on the actor message set enum variants).</p>
<p>Once it is spawned at runtime the <code>Actor</code> is moved into its own Tokio task. Since the <code>Actor</code> owns the actor state <code>S</code> this
guarantees actor encapsulation - it is not visible to the outside anymore. The task in turn consists of a loop that awaits
incoming messages from the actor mailbox (task channel reader part) and then dispatches the message through the <code>receive()</code>
function of the <code>ActorReceiver</code> impl.</p>
<p>Each <code>receive</code> match arm has to return a <code>ReceiveAction</code> enum that tells the task how to proceed:</p>
<ul>
<li><code>ReceiveAction::Continue</code> continues to loop, waiting for the next message to receive</li>
<li><code>ReceiveAction::Stop</code> breaks the loop and terminates message processing for this actor. This is the default
result when dispatching <code>_Terminate_</code> system messages</li>
<li><code>ReceiveAction::RequestTermination</code> sends a termination request to the associated <code>ActorSystem</code> but continues
to loop. The <code>ActorSystem</code> in turn sends <code>_Terminate_</code> messages to all its actors in response</li>
</ul>
<p>The system provides the <code>cont!{..}</code>, <code>stop!{..}</code> and <code>term!{..}</code> macros as syntatic sugar to make sure match arm expressions
do return respective <code>ReceiveAction</code> values.</p>
<h2 id="actorsystem"><a class="header" href="#actorsystem">ActorSystem</a></h2>
<p>Spawning actor tasks and transferring ownership of its <code>Actors</code> is the responsibility of the system provided <code>ActorSystem</code>
struct. Its main function therefore is <code>spawn_actor(..)</code> which is normally just called by the <code>spawn_actor!{..}</code> macro that
transparently</p>
<ul>
<li>creates a MPSC channel for the actor message set type</li>
<li>creates an <code>ActorHandle</code> that stores the sender part of the channel</li>
<li>creates an <code>Actor</code> from the provided actor state object and the <code>ActorReceiver</code> impl generated by the associated
<code>impl_actor!{..}</code> call (which means it has to be in scope at the point of the <code>spawn_actor{..}</code> call so that the
compiler can deduce the message type set)</li>
<li>spawns a new task with the system provided <code>run_actor(..)</code> task function, moving both the <code>Actor</code> and the receiver
part of the MPSC channel into this task</li>
</ul>
<p>The <code>ActorSystem</code> also keeps track of all running actors as a list of <code>SysMsgReceiver</code> trait objects. This means
<code>ActorSystem</code> can only interact with <code>Actors</code> by sending system messages. For this purpose <code>ActorSystem</code> has its own
task that processes <code>ActorSystemRequest</code> messages, of which the <code>ActorSystemRequest::RequestTermination</code> (sent by
<code>run_actor</code> in response to a <code>ReceiveAction::RequestTermination</code> return value from the actor <code>receive()</code> function) is
the most common one.</p>
<p>Based on its list of <code>SysMsgReceivers</code> the <code>ActorSystem</code> also manages heart beats (system liveness monitoring) and
a build-time configurable user interface to display the system status. Both are transparent to the application.</p>
<p><code>ActorSystem</code> is the primary object for actor based applications, which all follow the same general structure:</p>
<pre><pre class="playground"><code class="language-rust">...

#[tokio::main]
async fn main() -&gt;Result&lt;()&gt; {
    // create the actor system
    let mut actor_system = ActorSystem::new("main");

    // spawn actors
    let handle_a = spawn_actor!( actor_system, "A", ActorA{..})?;
    let handle_b = spawn_actor!( actor_system, "B", ActorB{..})?;
    ...

    // run the actor system
    actor_system.start_all().await?;
    actor_system.process_requests().await?;

    Ok(())
}</code></pre></pre>
<p>There are two underlying abstractions that can be varied for an <code>ActorSystem</code> implementation: async runtime and actor
task channel type. Both are configured by a <a href="https://doc.rust-lang.org/cargo/reference/features.html">Cargo build feature</a>
and provide the same interface. At this time we support</p>
<ul>
<li>the default <code>tokio_kanal</code> (<a href="https://tokio.rs/">Tokio</a> runtime and <a href="https://crates.io/crates/kanal">Kanal</a> MPSC channel type)</li>
<li><code>tokio_flume</code> (using the <a href="https://docs.rs/flume/latest/flume/">Flume</a> MPSC channel type)</li>
</ul>
<p>Within the same process only one combination can be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor-communication"><a class="header" href="#actor-communication">Actor Communication</a></h1>
<p>Actors don't live in isolation - their whole purpose is to build modular, scalable concurrent systems out of sets of
communicating actors. We therefore need to define</p>
<ul>
<li>what can be sent between actors (messages),</li>
<li>how we can send messages</li>
<li>how to program sender actors when, what and to whom messages should be sent</li>
</ul>
<p>Moreover, in <code>odin_actor</code> we need to do this in a type-safe, statically checked way. Since our implementation language
is Rust we want to ensure that</p>
<ul>
<li>we can only send thread- and memory-safe messages</li>
<li>we can only send messages to actors that handle them (are in the receiver's message interface)</li>
<li>each actor behavior is complete (no forgotten messages in the actor implementation)</li>
<li>actors combine (we can build systems out of generic actors that only need to know a minimum about each other)</li>
</ul>
<p>While the first three requirements are supported by Rust in a straight forward way, the forth requirement is complex.
Let's take it one step at a time.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>This one is easy - <code>odin_actor</code> does not have a specific message type or trait. Anything that is <code>Send</code> + <code>Debug</code> +
<code>'static</code> can be a message. The <code>Send</code> constraint is obvious as we pass messages between concurrent tasks (actors).
The<code>Debug</code> constraint is only for generic tracing/debugging support. The message type needs to be <code>static</code> since it is
part of the receiver actors definition. Some message sender methods do also require <code>Clone</code> as all sender methods do
consume the message argument. Should cloning be inefficient the message can also be an <code>Arc&lt;T&gt;</code>.</p>
<p>Since an actor typically processes more than one message we need to wrap all of its input message types into an <code>enum</code>.
This message set becomes part of the generic <code>Actor&lt;MsgSet,ActorState&gt;</code> type. Defining the message set is supported by
the <code>define_actor_msg_set!{..}</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_actor_msg_set! { MyActorMsg = Msg1 | Msg2 }
<span class="boring">}</span></code></pre></pre>
<p>which roughly expands to</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// automatically generated code
enum MyActorMsg {
   Msg1(Msg1),                // user messages...
   Msg2(Msg2),                
   _Start_ (_Start_),         // system messages...
   ... 
   _Terminate_ (_Terminate_) 
}
impl From&lt;Msg1&gt; for MyActorMsg { ... }
impl From&lt;Msg2&gt; for MyActorMsg { ... }
...
<span class="boring">}</span></code></pre></pre>
<p>The macro automatically adds variants for each of the system messages</p>
<ul>
<li><code>_Start_</code> - sent by the <code>ActorSystem</code> to indicate that all actors have been instantiated and should start to process</li>
<li><code>_Timer_</code> - sent by timers created from within the actor</li>
<li><code>_Exec_</code> - a generic message that executes the provided closure within the actor task</li>
<li><code>_Pause_</code> and <code>_Resume_</code> - can be used by actor systems that replay content</li>
<li><code>_Terminate_</code> - sent by the <code>ActorSystem</code> to indicate the application is about to shut down</li>
</ul>
<p>System messages don't need to be explicitly handled. They are sent either by the <code>ActorSystem</code> (e.g. <code>_Start_</code>) or
implicitly by <code>Actor</code> methods such as <code>start_timer(..)</code> or <code>exec(..)</code>.</p>
<p>The message set name (e.g. <code>MyActorMsg</code>) is then used to define the actor like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl_actor! { match msg for Actor&lt;MyActorMsg,MyActorState&gt; as
  Msg1 =&gt; ... // handle message 'msg' of type 'Msg1'
  Msg2 =&gt; ...
}
<span class="boring">}</span></code></pre></pre>
<p>Both <code>define_actor_msg_set!{..}</code> and <code>impl_actor!{..}</code> automatically translate generic message types (e.g. <code>Query&lt;Q,A&gt;</code>)
into valid variant names of the actor message set. Although this mapping is readable and intuitive the programmer does not
need to know (other than to understand related compiler error messages).</p>
<p>Using an enum to encode all possible input messages for an actor also explains why message types should not be large. Not
only would this increase <code>clone()</code> cost but it also would enlarge the message set enum, which is sized according to its largest
variant.</p>
<p><a id="message-size"></a>
Since this message set enum is the type of the actor mailbox (channel) this size matters - a Rust <code>enum</code> is sized according to
its largest variant. If the ratio of max to min size of variants is too large then the channel can waste a lot of memory. If this is a problem we can always wrap (part of) large messages within heap-allocated containers (<code>Box</code>, <code>Arc</code>, <code>Vec</code> etc.) which collapses the size of the wrapped data to a pointer.</p>
<h2 id="how-to-send-messages"><a class="header" href="#how-to-send-messages">How to Send Messages</a></h2>
<p>Actor mailboxes in <code>odin_actor</code> are implemented as bounded async channels. This means sending messages can block the
sender if the receiver queue is full. Since it depends on the actor/message types if this is acceptable we need to support
alternative send operations:</p>
<ul>
<li><code>send_msg(msg)</code> - this is an <code>async</code> function that can suspend the sender and hence can only be called from an <code>async</code> context</li>
<li><code>timeout_send_msg(msg,timeout)</code> - also <code>async</code> but guaranteed to finish in bounded time, possibly returning a timeout error</li>
<li><code>try_send_msg(msg)</code> - sync call. returning an error of the receiver queue is full</li>
<li><code>retry_send_msg(max_attempts,delay,msg)</code> - also sync but re-scheduling the message if receiver queue is full</li>
</ul>
<p>It is important to note that <code>retry_send_msg(..)</code> <em>can</em> violate the property that messages from the <em>same sender</em> are
processed by the receiver in the order in which they were sent. If partial send order is required this has to be
explicitly enforced in the sender.</p>
<p>All send operations return <code>Result&lt;(),OdinActorError&gt;</code> values. Senders should handle <code>ReceiverClosed</code> and - for async sends -
<code>ReceiverFull</code> and/or <code>Timeout</code> error values.</p>
<p>Send methods are defined in <code>ActorHandle</code>, <code>MsgReceiver</code> and <code>Actor</code> (the latter one used to send messages to itself).</p>
<p>Normal message send operations are unidirectional - should the sender expect a response that needs to retain request
information the responder has to do this association explicitly (e.g. by copying relevant request info into the response message, or by keeping a list of pending requests in the sender).</p>
<h2 id="waiting-for-a-response---queryqa"><a class="header" href="#waiting-for-a-response---queryqa">Waiting for a Response - <code>Query&lt;Q,A&gt;</code></a></h2>
<p>The bi-directional <code>query(..)</code> operations overcome this restriction in cases where the sender should wait for a response
before going on. The underlying message type is a generic <code>Query&lt;Question,Answer&gt;</code> struct which has to be in the
responders input message set, the concrete <code>Question</code> and <code>Answer</code> types being provided by the user (with normal message
type constraints).</p>
<p>The requester sends queries like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
  let question = ... 
  match query( responder_handle, question).await {
     Ok(response) =&gt; ... // process response value
     Err(e) =&gt; ... // handle failed query
  }
<span class="boring">}</span></code></pre></pre>
<p>The corresponding responder code would be:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_actor_msg_set! { ResponderMsg = ... | Query&lt;Question,Answer&gt; | ...}

impl_actor!{ match msg for Actor&lt;ResponderMsg,ResponderState&gt; as
  ...
  Query&lt;Question,Answer&gt; =&gt; {
     let answer = ...
     if let Err(e) = msg.respond( answer).await {
       ...// handle response send error
     }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>In many other actor system libraries this is known as the <em>ask pattern</em>.</p>
<p>If the requester message processing should not be blocked (i.e. there are other messages the requester still has to
react to while waiting for a response) the query should be performed from a spawned task. Since the task closure can
capture the query context (e.g. the question) this can still be preferrable to explicit request/response mapping for
one-way messages.</p>
<p>Due to this round trip (and potential per request response channel allocation) queries are less efficient than
normal message send operations. For repetitive queries from within the same requester there is a <code>QueryBuilder</code>
that avoids the response channel allocation for consecutive queries of the same type.</p>
<h2 id="how-to-make-senders-generic---receivers-and-actions"><a class="header" href="#how-to-make-senders-generic---receivers-and-actions">How to Make Senders Generic - Receivers and Actions</a></h2>
<p>This is the big topic for typed actor communication in (open) actor system frameworks:</p>
<p class="standout">how to connect actors from different domains that do not know about each other?</p>
<p>In other words - how do we make actors in open actor systems reusable in different contexts. This is not a
problem if actors are just used in a single application or a single domain (such as a generic web server) - here the set
of actor and message types is closed and known a priori. It becomes a vital problem for a framework such as <code>odin_actor</code>
that is meant to be extended by 3rd parties and for various kinds of applications.</p>
<p>This section describes the levels at which we can separate sender and receiver code in <code>odin_actor</code>,</p>
<p>The basis for all this is how we can specify the receiver of a particular message within the sender</p>
<h3 id="1-actorhandlem" class="bottom-sep"><a class="header" href="#1-actorhandlem">(1) <code>ActorHandle&lt;M&gt;</code></a></h3>
<p><code>ActorHandle&lt;M&gt;</code> fields can be used to send messages of any variant of the message set that is defined by the
<code>define_actor_msg_set</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_actor_msg_set!{ MyMsgSet = Msg1 | Msg2 | ..}
...
impl_actor! { match msg for Actor&lt;MyMsgSet,MyActorState&gt; as 
   Msg1 =&gt; ...
   Msg2 =&gt; ...
   ...
}
<span class="boring">}</span></code></pre></pre>
<p>This is the least amount of separation between sender and receiver since the sender has to know the full message
interface of the receiver (e.g. <code>MyMsgSet</code>), not only the message it wants to send (e.g. <code>Msg2</code>). In most cases this is
synonym to knowing the concrete type of the receiver actor, which practically limits this mechanism to very general
receivers or to actors from the same domain (i.e. actors that know about their concrete types anyways).</p>
<p><code>ActorHandle&lt;M&gt;</code> is a <code>struct</code> that is <code>Clone</code> + <code>Send</code>, hence it can be sent in messages and stored in fields.
Cloning <code>ActorHandle</code> is inexpensive.</p>
<p>Normally <code>ActorHandles</code> are created by calling our <code>spawn_actor!(..)</code> macro. Sometimes we need to create an
<code>ActorHandle</code> <strong>before</strong> we can spawn the actor, e.g. if there are cyclic dependencies between actors. For this purpose
<code>odin_actor</code> provides a <code>PreActorHandle</code> struct that can only be used for two purposes: (a) to subsequently spawn an
actor (using the <code>spawn_pre_actor!(..)</code> macro) and (b) to explicitly create a compatible <code>ActorHandle</code> from it that can
be stored/used by other actors. Note that <code>PreActorHandle</code> does not compromise type safety or actor encapsulation.</p>
<h3 id="2-msgreceivert-and-msgreceiverlistt" class="bottom-sep"><a class="header" href="#2-msgreceivert-and-msgreceiverlistt">(2) <code>MsgReceiver&lt;T&gt;</code> and <code>MsgReceiverList&lt;T&gt;</code></a></h3>
<p><code>MsgReceiver&lt;T&gt;</code> can be used to send messages of a single type <code>T</code> to the receiver (if <code>T</code> is in the receiving actors
message set - see above). This is the next level of separation since now the sender only has to know that the receiver
understands <code>T</code> - it does not need to know what other messages the receiver processes.</p>
<p><code>ActorHandle&lt;M&gt;</code> has a blanket impl for <code>MsgReceiver&lt;T&gt;</code> for all variants of its message set <code>M</code>.</p>
<p><code>MsgReceiver&lt;T&gt;</code> is a trait, which means it can only be stored within the sender using a type variable</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MySender&lt;R&gt; where R: MsgReceiver&lt;SomeMsg&gt; {
   receiver: R, ...
}
<span class="boring">}</span></code></pre></pre>
<p>To support heterogenous lists of <code>MsgReceiver&lt;T&gt;</code> implementors we provide a <code>MsgReceiverList&lt;T&gt;</code> trait together with
a <code>msg_receiver_list!(..)</code> macro that can be used like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   //--- receiver actor module(s)
   define_actor_msg_set! { Receiver1Msg =  Msg1 | ... }
   define_actor_msg_set! { Receiver2Msg =  ... | Msg1 | ... }
   ...
   struct Receiver1 { ... }
   struct Receiver2 { ... }

   //--- sender actor module
   struct MySender&lt;L&gt; where L: MsgReceiverList&lt;Msg1&gt; {
      receivers: L, ...
   }
   impl&lt;L&gt; MySender&lt;L&gt; where L: MsgReceiverList&lt;Msg1&gt; {
      ... self.receivers.send_msg( Msg1{...}, true).await ...
   }

   //--- actor system construction (main)
   let receiver1_handle = spawn_actor!( actor_system, "recv1", Receiver1 {..});
   let receiver2_handle = spawn_actor!( actor_system, "recv2", Receiver2 {..});

   spawn_actor!( actor_system, "sender", 
                 Sender::new( msg_receiver_list!( receiver1_handle, receiver2_handle : MsgReceiver&lt;Msg1&gt;) ))
<span class="boring">}</span></code></pre></pre>
<p><code>MsgReceiverList&lt;T&gt;</code> has the usual send functions but adds a <code>ignore_err: bool</code> argument to each of them, defining
if the send operation for the list should ignore error results for its elements. If set to false, the first element
send operation that fails shortcuts the list send operation.</p>
<p><code>MsgReceiver&lt;T&gt;</code> and <code>MsgReceiverList&lt;T&gt;</code> represent static receiver types - with them we cannot dynamically add
new receivers at runtime.</p>
<h3 id="3-dynmsgreceivert-and-dynmsgreceiverlistt" class="bottom-sep"><a class="header" href="#3-dynmsgreceivert-and-dynmsgreceiverlistt">(3) <code>DynMsgReceiver&lt;T&gt;</code> and <code>DynMsgReceiverList&lt;T&gt;</code></a></h3>
<p><code>DynMsgReceiver&lt;T&gt;</code> is a type that allows us to send and store <code>MsgReceiver&lt;T&gt;</code> implementors as trait objects at
runtime. It is boxing a normally transparent <code>DynMsgReceiverTrait&lt;T&gt;</code> for which <code>ActorHandle&lt;M&gt;</code> has blanket impls.
It is less efficient than the static <code>MsgReceiver&lt;T&gt;</code> since it incurs extra runtime cost for each send
operation (pin-boxing the futures returned by its send operations).</p>
<p><code>DynMsgReceiverList&lt;T&gt;</code> is a container for <code>DynMsgReceiver&lt;T&gt;</code> objects. It is used like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   //--- receiver actor module(s)
   define_actor_msg_set! { Receiver1Msg =  Msg1 | ... }
   
   struct Receiver1&lt;S&gt; where S: MsgReceiver&lt;AddMsg1Receiver&gt; { sender: S... }

   impl_actor! { match msg for Actor&lt;Receiver1&lt;S&gt;,Receiver1Msg&gt; where S: MsgReceiver&lt;AddMsg1Receiver&gt; as
      ... self.sender.send_msg( AddMsg1Receiver(self.hself.into())).await ...
      Msg1 =&gt; ...
   }

   define_actor_msg_set! { Receiver2Msg =  ... | Msg1 | ... }
   struct Receiver2&lt;S&gt; where S: MsgReceiver&lt;AddMsg1Receiver&gt; { sender: S... }
   ...

   //--- sender actor module
   #[derive(Debug)]
   struct AddMsg1Receiver(DynMsg1Receiver&lt;Msg1&gt;);

   define_actor_msg_set! { MySenderMsg = AddMsg1Receiver | ...}

   struct MySender  {
      receivers: DynMsgReceiverList&lt;Msg1&gt;, ...
   }

   impl_actor! { match msg for Actor&lt;MySender,MySenderMsg&gt; as 
      AddMsg1Receiver =&gt; cont! { self.receivers.push(msg.0) }
      ...
      ... self.receivers.send_msg( Msg1{..}, true).await ...
   }

   //--- actor system construction (main)
   let sender = spawn_actor!( actor_system, "sender", MySender {..});
   spawn_actor!( actor_system, "recv1", Receiver1{sender, ...});
   spawn_actor!( actor_system, "recv2", Receiver2{sender, ...});
<span class="boring">}</span></code></pre></pre>
<p><code>MsgReceiverList&lt;T&gt;</code> and <code>DynMsgReceiverList&lt;T&gt;</code> are used to implement static/dynamic publish/subscribe patterns.
They allow us to abstract concrete receiver types our sender can communicate with, provided all these
receivers have the message type we send in their message set.</p>
<p>The limitations are that both sender and receivers have to know the respective message type, and the sender has
to know how to instantiate that message. This is a serious constraint for multi-domain frameworks.</p>
<h3 id="4-dataactiont-and-the-data_action-macro" class="bottom-sep"><a class="header" href="#4-dataactiont-and-the-data_action-macro">(4) <code>DataAction&lt;T&gt;</code> and the <code>data_action!{..}</code> macro</a></h3>
<p><code>DataAction&lt;T&gt;</code>is an abstraction that overcomes the limitation of being able to send only one message type
and having to hard-code message construction in the sender actor (which might not know the messages understood
by potential receivers).</p>
<p>Data actions are defined and documented in the [<code>odin_action</code>] crate - while the <strong>action</strong> construct is not
actor specific it is most useful to make actors from different domains inter-operable. They can be viewed as
async "callbacks" that allow the sender to inject its own data into action executions. All the sender actor
has to know is when to execute an action and what data to provide for its execution.</p>
<p>Actions can be defined explicitly as in:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   // sender actor definition 
   struct Sender&lt;A&gt; where A: DataAction&lt;SenderData&gt; {
       action: A, ...
   }
   impl&lt;A&gt; Sender&lt;A&gt; where A: DataAction&lt;SenderData&gt; {
       ...
         let data: SenderData = ...; // create the data that should be passed into the action
         self.action.execute( data ).await ...
   }
   ...
   // action definition (at the actor system construction site, e.g. main())
   struct MyDataAction {..}
   impl DataAction&lt;SenderData&gt; for MyAction {
       async fn execute (data: &amp;SenderData)-&gt;Result&lt;()&gt; { ... } // ⬅︎ concrete action defined here
   }

   ...  Sender::new( MyDataAction{..}, ...)
<span class="boring">}</span></code></pre></pre>
<p>More often actions are one-of-a-kind objects that are defined and instantiated through the macros that are
provided by [<code>odin_action</code>], and their action expressions are sending messages to other actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // actor modules
  define_actor_msg_set! { Receiver1Msg = Msg1 | ... }
  define_actor_msg_set! { Receiver2Msg = ... | Msg2 | ... }
  ...
  struct Sender&lt;A&gt; where A: DataRefAction&lt;SenderData&gt; { 
     data: SenderData,
     action: A, ...
  }
  impl&lt;A&gt; Sender&lt;A&gt; where A: DataRefAction&lt;SenderData&gt; {
    fn new (action: A)-&gt;Self { ... }

    ... self.action.execute(&amp;self.data).await ...
  }
  
  // actor system construction site (e.g. main() function)
     receiver1 = spawn_actor!( actor_system, "recv1", Receiver1{..})?;
     receiver2 = spawn_actor!( actor_system, "recv1", Receiver1{..})?;
     ...
     sender = spawn_actor!( actor_system, "sender", Sender::new(
         dataref_action!( receiver1: ActorHandle&lt;Receiver1Msg&gt;, receiver2: ActorHandle&lt;Receiver2Msg&gt; =&gt; |data: &amp;SenderData| {
            receiver1.send_msg( Msg1::new( ...data.clone().,,)).await?;
            receiver2.try_send_msg( Msg2::new(...data.translate() ...))
         })
     ))?;
<span class="boring">}</span></code></pre></pre>
<p>The interesting aspect about the <code>data_action!(..)</code> macros is that they can capture data from the macro call site without
requiring a closure (Rust does not yet support async closures). The general pattern of the macro call is as follows:</p>
<pre><code>data_action!( «captured-receiver-var» :  «capture-type», ... =&gt; |«data-var»: «data-var-type»| «execute-expr»)
</code></pre>
<p>While data actions effectively separate sender and receiver code there is one last constraint: data actions have to be created
upfront, at system construction time. We cannot send them to actors.</p>
<h3 id="6-dyndataactiont-and-the-dyn_data_action-macro" class="bottom-sep"><a class="header" href="#6-dyndataactiont-and-the-dyn_data_action-macro">(6) <code>DynDataAction&lt;T&gt;</code> and the <code>dyn_data_action!{..}</code> macro</a></h3>
<p>The [<code>odin_action</code>] crate also supports dynamic (trait object) actions through its [<code>dyn_data_action</code>] and [<code>dyn_dataref_action</code>]
macros, which does allow to send actions in messages. This is in turn useful to</p>
<ul>
<li>execute such actions when the receiver processes the containing message</li>
<li>store actions for later execution (e.g. in a subscriber list)</li>
</ul>
<p>To store action trait objects and execute their entries [<code>odin_action</code>] provides the [<code>DynDataActionList</code>] and
[<code>DynDataRefActionList</code>] containers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// receiver actor impl module
struct Msg1 { .. }
...
define_actor_msg_set { ReceiverMsg = Msg1 | ... }
...
impl_actor! { match msg for Actor&lt;ReceiverMsg,Receiver&gt; as
   Msg1 =&gt; ...
   ...
}

// sender actor impl module
struct AddUpdateAction(DynDataRefAction&lt;SenderData&gt;)
...
define_actor_msg_set { SenderMsg = AddUpdateAction | PublishChanges | ... }

struct Sender {
   data: SenderData,
   update_action: DynDataRefActionList&lt;SenderData&gt; 
   ...
}
impl_actor! { match msg for Actor&lt;SenderMsg,Sender&gt; as
   AddUpdateAction =&gt; { ... self.update_action.push( msg.0) ... }
   PublishChanges =&gt; { ... self.update_action.execute( &amp;self.data).await ... }
   ...
}
...
// actor system construction module
...
receiver = spawn_actor!( actor_system, "receiver", Receiver::new(..))?;
sender = spawn_actor!( actor_system, "sender", Sender::new(..))?;
...
let action = send_msg_dyn_action!( receiver, |data: &amp;SenderData| Msg1::new(data));
sender.send_msg( AddUpdateAction(action)).await?;
<span class="boring">}</span></code></pre></pre>
<p>Actions sent in messages can also be executed when the receiver processes such messages. Since dyn actions can capture
data from the creation site (within the sender code) this can be useful as a less expensive alternative to the <code>query()</code>
mechanism described above (only using the normal actor task context).</p>
<p>With power comes responsibility - being able to use loops within action bodies we have to be aware of two potential
problems:</p>
<ul>
<li>back pressure and</li>
<li>loss-of-information</li>
</ul>
<p>The back pressure problem arises if we send messages from within iteration cycles, as in:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>... dataref_action( ... |data: &amp;Vec&lt;SomeData&gt;| {...
      for e in data {
         ... receiver.try_send_msg( SomeMessage::new(e)); ...
      }
    }) ...
<span class="boring">}</span></code></pre></pre>
<p>This can result in <code>OdinActorError::ReceiverFull</code> results when sending messages. If we use <code>try_send_msg(..)</code> without
processing the return value (as in above snippet) this might even be silently ignored. The solution for this is to
either check the return value or use</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>         ... receiver.send_msg( SomeMessage::new(e)).await ...
<span class="boring">}</span></code></pre></pre>
<p>In this case we have to be aware though that the sender might get blocked, i.e. becomes un-responsive if it is also
a potential message receiver. Should this apply we can run the loop from within a spawned task.</p>
<p>There also might be a (semantic) loss-of-information problem if we need to preserve that all messages sent from within
the loop came from the same input data (the <code>execute()</code> argument). Unless receivers could easily reconstruct this from
the respective message payload the solution is to collect the payloads into a container and send that container as one
message, which turns the above case into:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>... dataref_action( ... |data: &amp;Vec&lt;SomeData&gt;| {...
      let msg_payload: Vec&lt;SomePayload&gt; = data.iter().map(|e| payload(e)).collect();
      receiver.try_send_msg( SomeMessage::new( msg_payload)) ...
    }) ...
<span class="boring">}</span></code></pre></pre>
<p>This also addresses the message variant size problem mentioned (above)[#message-size].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>
<p>The <code>odin_actor/examples</code> directory contains a set of runnable example applications that each introduce and demonstrate a single
<code>odin_actor</code> feature. It is recommended to go through examples in the following sequence:</p>
<ul>
<li><a href="odin_actor/examples/odin_actor/examples/hello_world.html"><code>hello_world</code></a> : the basics (actorsystem, actor and sending messages)</li>
<li><a href="odin_actor/examples/odin_actor/examples/sys_msgs.html"><code>sys_msgs</code></a> : using system messages and timers</li>
<li><a href="odin_actor/examples/odin_actor/examples/spawn.html"><code>spawn</code></a> : spawning one-shot async tasks from within actors</li>
<li><a href="odin_actor/examples/odin_actor/examples/spawn_blocking.html"><code>spawn_blocking</code></a> : spawn blocking tasks (running in threads) from within actors</li>
<li><a href="odin_actor/examples/odin_actor/examples/exec.html"><code>exec</code></a> : using the generic <code>exec(..)</code> to execute closures within actor tasks</li>
<li><a href="odin_actor/examples/odin_actor/examples/jobs.html"><code>jobs</code></a> : scheduling generic jobs with the actor system global <code>JobScheduler</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/producer_consumer.html"><code>producer_consumer</code></a> : point-to-point actor communication with <code>MsgReceiver</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/pub_sub.html"><code>pub_sub</code></a> : publish/subscribe communication using a static <code>MsgReceiverList&lt;T&gt;</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/dyn_pub_sub.html"><code>dyn_pub_sub</code></a> : dynamic publish/subscribe communication using <code>DynMsgReceiver&lt;T&gt;</code> and <code>DynMsgReceiverList&lt;T&gt;</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/pin_pong.html"><code>ping_pong</code></a> : managing cyclic actor dependencies with <code>PreActorHandle</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/query.html"><code>query</code></a> : using <code>Query&lt;Q,A&gt;</code> to send a message and wait for an answer</li>
<li><a href="odin_actor/examples/odin_actor/examples/dyn_actor.html"><code>dyn_actor</code></a> : dynamically create actors from within actors</li>
<li><a href="odin_actor/examples/odin_actor/examples/actions.html"><code>actions</code></a> : statically configure actor interaction with <code>DataAction</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/dyn_actions.html"><code>dyn_actions</code></a> : dynamically configure actor interaction with <code>DynDataAction</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/retry.html"><code>retry</code></a> : handling back-pressure with <code>retry_send_msg(..)</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/requests.html"><code>requests</code></a> : sequential processing of requests in background task</li>
<li><a href="odin_actor/examples/odin_actor/examples/actor_config.html"><code>actor_config</code></a> : configuring actors with the <code>config_for!(..)</code> macro</li>
<li><a href="odin_actor/examples/odin_actor/examples/heartbeat.html"><code>heartbeat</code></a> : monitoring actor systems with heartbeat messages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello_world"><a class="header" href="#hello_world">hello_world</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sys_msgs"><a class="header" href="#sys_msgs">sys_msgs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn"><a class="header" href="#spawn">spawn</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn_blocking"><a class="header" href="#spawn_blocking">spawn_blocking</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exec"><a class="header" href="#exec">exec</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jobs"><a class="header" href="#jobs">jobs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="producer_consumer"><a class="header" href="#producer_consumer">producer_consumer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pub_sub"><a class="header" href="#pub_sub">pub_sub</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ping_pong"><a class="header" href="#ping_pong">ping_pong</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query"><a class="header" href="#query">query</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn_actor"><a class="header" href="#dyn_actor">dyn_actor</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions"><a class="header" href="#actions">actions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn_actions"><a class="header" href="#dyn_actions">dyn_actions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retry"><a class="header" href="#retry">retry</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requests"><a class="header" href="#requests">requests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor_config"><a class="header" href="#actor_config">actor_config</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heartbeat"><a class="header" href="#heartbeat">heartbeat</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_server"><a class="header" href="#odin_server">odin_server</a></h1>
<p>The <code>odin_server</code> system crate provides the infrastructure to create servers. The primary server type is the
<code>SpaServer</code> which implements a <a href="https://en.wikipedia.org/wiki/Single-page_application"><em>Single Page Application</em></a>
web server with composable <code>SpaService</code> (<a href="https://en.wikipedia.org/wiki/Microservices"><em>micro service</em></a>) stacks.
The crate it based on the <a href="https://docs.rs/axum/latest/axum/">Axum</a> framework and hence seamlessly integrates with
the <a href="https://docs.rs/tokio/latest/tokio/index.html">Tokio</a> async runtime that is also used for our actor system
implementation in the <a href="odin_server/../odin_actor/odin_actor.html">odin_actor</a> crate.</p>
<p>The general use case for our servers is to support soft-realtime updates of sensor and tracking data down to 1Hz
latency. To achieve this we push data updates over websockets to all connected clients and hence assume a limited
number of simultaneous users (&lt; 1000).</p>
<p>The primary constructs of <code>odin_server</code> are</p>
<ul>
<li>the <code>SpaServer</code> actor</li>
<li>the <code>SpaService</code> trait</li>
</ul>
<p>There is one <code>SpaServer</code> actor and an open number of <code>SpaService</code> trait implementations, hence the latter is the main
abstraction of <code>odin_server</code>. <code>SpaService</code> instances often act as display layers for a multitude of dynamic data types
such as tracked objects, weather info and satellite observations.</p>
<p>A <code>SpaService</code> has two main purposes:</p>
<ul>
<li>provide the components that are served via http.
The main resource component of a <code>SpaService</code> is usually a Javascript module that contains the client-side code to communicate with the server and to display data received from it. Those <em>assets</em> make full use of the <a href="odin_server/../odin_build/odin_build.html">odin_build</a> crate, i.e.
they can be inlined (for stand-alone servers) or looked up in a number of file system locations</li>
<li>trigger the initial data download via websocket when a new client (browser) connects.</li>
</ul>
<p>Dynamic data such as tracked objects normally comes from a separate <em>DataActor</em> that is associated with a <code>SpaService</code>. Although this is a role (not a type) it has a common message interface to <code>SpaServer</code>:</p>
<ul>
<li>announce availability of data</li>
<li>provide a current data snapshot to be sent to new clients (connected browsers)</li>
<li>provide data updates to be sent to all clients when the internal state changes</li>
</ul>
<pre><code>                     ┌────────────────────────┐                      
                     │      SpaServer         │                assets
                     │                        │      ┌─────────────┐ 
                     │  ┌──────────────────┐  │   ┌──┤  js-module  │ 
                     │  │  SpaServiceList  │  │   │  └─────────────┘ 
                     │  │                  │  │   │  ┌─────────────┐ 
┌───────────┐        │  │ ┏━━━━━━━━━━━━┓◄──┼──┼───┼──┤     ...     │ 
│ DataActor ├─┐ ◄────┼──┼─┃ SpaService ┃─┐ │  │   │  └─────────────┘ 
└─┬─────────┘ │      │  │ ┗━┯━━━━━━━━━━┛ │ │  │   │                  
  └─────┬─────┘      │  │   └────────────┘ │  │   │           proxies
        │            │  └──────────────────┘  │   └──── name | url   
        │            │                        │         ...  | ...   
        │            │      connections       │                      
        │  init      │  ┌──────────────────┐  │                      
        └───────────►│  │ip-addr  websocket│  │                      
           update    │  │  ...      ...    │  │                      
                     │  └──────────────────┘  │                      
                     │                        │                      
                     └────┬─────────────▲─────┘                      
                          │             │                            
                 - - - - -│- - - - - - -│- - - - - -                 
                   http://│             │wss://                      
                          ▼   clients   ▼                                                
</code></pre>
<p>The <code>SpaServer</code> actor encapsulates two pieces of information:</p>
<ul>
<li>the static <code>SpaServiceList</code> that contains an ordered sequence of <code>SpaService</code> trait objects for the web application.
This list is provided as a <code>SpaServer</code> contstructor parameter (e.g. created in <code>main()</code>) but uses its own type since <code>SpaService</code> instances can depend on other SpaServices.</li>
<li>the dynamic list of client connections (client IP address and associated websocket)</li>
</ul>
<p><code>SpaServer</code> has an internal and external message interface. The internal interface is used to update the connection list (which
is not shared with the <code>SpaServices</code>). The external interface includes two generic message types sent by <em>DataActors</em>:</p>
<ul>
<li><code>SendWsMsg(ip_addr,data)</code> to send data snapshots to a new connection (address provided in the message)</li>
<li><code>BroadcastMsg(data)</code> to broadcast data updates to all current connections</li>
</ul>
<p>We use <a href="https://www.json.org/json-en.html">JSON</a> for all websocket communications.</p>
<p><code>SpaServer</code>, <code>SpaService</code> and <em>DataActor</em> implementations do not need to know each other, they can reside in different crates and
even domains (system or application). This is mostly achieved through <code>SpaService</code> trait objects and
<a href="odin_server/../odin_action/odin_action.html"><code>odin_action</code> data actions</a> which are set in the only code that needs to know the concrete types - the
actor system instantiation site (e.g. <code>main()</code>).</p>
<p>Each web application actor system is implemented as a single executable. In general, development of new web applications therefore
involves two steps:</p>
<ol>
<li>creating <em>DataActor</em> and associated <code>SpaService</code> implementations for new data sources</li>
<li>writing code that instantiates the required actors and connects them through <em>data actions</em>
(see <a href="odin_server/../odin_action/odin_action.html">odin_action</a>)</li>
</ol>
<h2 id="1-creating-spaservice-implementations"><a class="header" href="#1-creating-spaservice-implementations">1. Creating <code>SpaService</code> Implementations</a></h2>
<p>As a <code>SpaService</code> has the two main functions of (1) initializing the server and then (2) initializing clients through their
websockets. We look at these steps in sequence.</p>
<h3 id="11-initializing-the-server"><a class="header" href="#11-initializing-the-server">1.1 Initializing the Server</a></h3>
<p><code>SpaService</code> objects are <code>SpaServer</code> constructor arguments. They have to be created first but instead of passing them directly
into the <code>SpaServer</code> constructor we use a <code>SpaServiceList</code> accumulator to do so. The rationale is that <code>SpaServices</code> can depend
on each other, e.g. a track service depending on the framework provided websocket and virtual globe rendering services.
<code>SpaServiceList</code> is used to make sure only one service of each type name is included. It is initialized like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SpaServiceList::new()
    .add( build_service!( GoesrService::new(...)) )
    ...
<span class="boring">}</span></code></pre></pre>
<p>The <code>odin_server::build_service!(expr)</code> macro is just syntactic sugar that wraps the provided expr into a closure to defer the actual creation of the service until we know its typename has not been seen yet. The <code>SpaServiceList::add()</code> funtion then calls the <code>SpaService::add_dependencies(..)</code> implementation, which can recursively repeat the process:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn add_dependencies (&amp;self, svc_list: SpaServiceList) -&gt; SpaServiceList {
        svc_list
            .add( build_service!( UiService::new()))
            .add( build_service!( WsService::new()))
    }
<span class="boring">}</span></code></pre></pre>
<p>While <code>SpaServiceList</code> is used to accumulate the required <code>SpaService</code> instances it is not used to store them in the <code>SpaServer</code>.
Instead, we extract these instances and wrap them as trait objects in an internal <code>SpaSvc</code> type that allows us to add some
service specific state.  Once a <code>SpaServer</code> actor receives a <code>_Start_</code> system message it begins to assemble the served document by traversing the stored <code>SpaService</code> trait objects.</p>
<p>There are two component types each <code>SpaService</code> can add:</p>
<ul>
<li>document fragments (HTML elements such as scripts)</li>
<li>routes (HTML GET/POST handlers that respond to service specific asset requests)</li>
</ul>
<p>Again, the <code>SpaServer</code> does not add such components directly to the generated HTML document and Axum handlers but accumulates them in a
<code>SpaComponents</code> struct that can filter out redundant components (e.g. external script references). The <code>SpaComponets</code> type is
essentially our single page document model that includes:</p>
<ul>
<li>header items (CSS links, external script links, <code>odin_server</code> Javascript modules)</li>
<li>body fragments (HTML elements)</li>
<li>routes (the HTML URIs we serve)</li>
<li>proxies (a map of symbolic external server names to their respective base URIs)</li>
<li>assets (a map from symbolic asset filenames to <code>SpaService</code> crate specific <code>load_asset()</code> lookup functions)</li>
</ul>
<p><code>SpaComponents</code> includes methods to add each of those components from within <code>SpaService::add_components(..)</code> implementations like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn add_components (&amp;self, spa: &amp;mut SpaComponents) -&gt; OdinServerResult&lt;()&gt;  {
        spa.add_assets( self_crate!(), load_asset);
        spa.add_module( asset_uri!("odin_sentinel_config.js"));
        spa.add_module( asset_uri!("odin_sentinel.js"));

        spa.add_route( |router, spa_server_state| {
            router.route( &amp;format!("/{}/sentinel-image/*unmatched", spa_server_state.name.as_str()), get(Self::image_handler))
        });

        Ok(())
    }
<span class="boring">}</span></code></pre></pre>
<p><code>SpaService</code> implementor crates use the <a href="odin_server/../odin_build/odin_build.html">odin_build</a> crate to generate respective <code>load_asset(..)</code> functions
from their <code>lib.rs</code> modules like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use odin_build::define_load_asset;
...
define_load_asset!{}
...
<span class="boring">}</span></code></pre></pre>
<p>Although our own <code>SpaService</code> specific Javascript modules are looked up/served through this <code>load_asset()</code> function we have to
add them explicitly through calling <code>add_asset(..)</code> since our document model supports post-initialization hooks that are automatically
called at the end of the BODY element and we have to ensure that all (possibly asynchronous) Javascript modules are initialized
at this point.</p>
<p><code>SpaService</code> implementations only have to add the components they need. Once all services have added their components the <code>SpaServer</code>
calls the <code>SpaComponents::to_html(..)</code> function to generate the served document and generates required Axum
<a href="https://docs.rs/axum/latest/axum/index.html#routing">routers</a> with their respective
<a href="https://docs.rs/axum/latest/axum/index.html#handlers">handler</a> functions.</p>
<pre><code>                                               ┌──────────────┐                           
                                               │ OtherService │                   configs 
                                               └──────┬───────┘         ┌──────────────┐  
                  ┌──────────────┐                    │       ┌─────────┤my_service.ron│  
                  │SpaServiceList│                    │       │   init  └──────────────┘  
                  └──┬──▲────────┘                    │       │                           
                     │  │   ┌─────────────────────────┼───────▼──┐                 assets 
 _Start_             │  │   │ MyService : SpaService  │          │       ┌─────────────┐  
                     │  │   │                         ▼          │    ┌──┤my_service.js│  
    start()_server() │  └───┼─ add_dependencies(svc_list)        │    │  └─────────────┘  
                     ▼      │                                    │    │  ┌─────────────┐  
           build_router()  ◄┼─ add_components(spa_components)◄───┼────┼──┤     ...     │  
                     │      │                         │          │    │  └─────────────┘  
                     │      │  ...                    │          │    │                   
                     │      └─────────────────────────│──────────┘    │           proxies 
                     ▼                                ▼               └──── name | url    
               doc_handler()  ◄────────────────── document                  ...  | ...    
                                                                                          
               asset_handler()                                                            
                                                                                          
               proxy_handler()                                                            
                     │                                                                    
                     ▼                                                                    
                 http://                                                                  
</code></pre>
<p>At this point <code>SpaServer::start_server()</code> spawns the Axum <code>TcpListener</code> task and we are ready to serve client requests.</p>
<h3 id="12-initializing-and-updating-clients"><a class="header" href="#12-initializing-and-updating-clients">1.2 Initializing and Updating Clients</a></h3>
<p>Most application domain <code>SpaService</code> implementations involve dynamic data that needs to be pushed to connected browsers. That
data typically does not get generated by the <code>SpaService</code> itself but by some dedicated <em>DataActor</em> that is only concerned about
maintaining that data, not about distributing or rendering it. To make this available in a web server context we use
interaction between the respective <code>SpaService</code>, its <em>DataActor</em> and the <code>SpaServer</code>.</p>
<p>There are two types of interaction</p>
<ul>
<li>initialization of new clients</li>
<li>update of all connected clients</li>
</ul>
<p>Since we need to push data both work by sending JSON messages over the websocket associated with a client.</p>
<p>New connections are deteced by a request for the websocket URI that is handled by the framework provided <code>WsService</code> (which
is a dependency for all dynamic data services). Once the protocol upgrade (http -&gt; ws) is accepted the <code>WsService</code> handler sends
an internal <code>AddConnection</code> message to the <code>SpaServer</code> which in response stores the new remote address and websocket in its
connection list and then calls the <code>init_connection(..)</code> method of all its <code>SpaServices</code>.</p>
<p>The <code>SpaService::init_connection(..)</code> implementations then send a message to their <em>DataActor</em> that contains a
<a href="odin_server/odin_action/odin_action.html"><code>odin_action::DynDataRefAction</code></a> object which captures both the handle of the <code>SpaServer</code> actor
and the ip address of the new connection. When the <em>DataActor</em> processes that message it executes the <code>DynDataRefAction</code>
passing in a reference to its internal data. The action body itself generates a JSON message from the data reference and
sends it as a <code>SendWsMsg</code> message to the <code>SpaServer</code> actor, which then uses the remote ip address of the message to look up
the corresponding websocket in its connection list and then sends the JSON message payload over it.</p>
<pre><code>                                   ┌────────────────────────────────────────────────┐
                                   │                  SpaServer                     │
                                   │                                                │
                                   │  ┌─────────────────────────────────────┐       │
                                   │  │ MyService : SpaService              │       │
┌─────────────────┐                │  │                                     │       │
│    DataActor    │                │  │  ...                                │       │
│                 │ DataAvailable  │  │                                     │       │
│ [init_action]  ─┼────────────────┼──┼► data_available(hself,has_conn,..)  │       │
│                 │                │  │                                     │       │
│ exec( action) ◄─┼────────────────┼──┼─ init_connection(hself,has_data,..)◄─────────────┐
│        │        │                │  │                                     ├────┐  │    │AddConnection
│        │        │                │  └─────────────────────────┬───────────┘    │  │    │
│        │        │   SendWsMsg    │                            │     WsService  ────────┘ 
│        └────────┼────────────────┼──► send_ws_msg()           └────────────────┘  │
│                 │                │                              ┌───────────┐     │
│ [update_action]─┼────────────────┼──► broadcast_ws_msg() ◄──────┤connections│     │
│                 │ BroadcastWsMsg │         │                    └───────────┘     │
└─────────────────┘                │         │                                      │
                                   └─────────┼──────────────────────────────────────┘
                                             │                                    
                                             │                                    
                                             ▼                                    
                                           wss://                                 
</code></pre>
<p>A typical <code>SpaService::init_connection(..)</code> implementation looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn init_connection (&amp;mut self, hself: &amp;ActorHandle&lt;SpaServerMsg&gt;, is_data_available: bool, conn: &amp;mut SpaConnection) 
  -&gt; OdinServerResult&lt;()&gt; {
        ...
        if is_data_available {
            let action = dyn_dataref_action!( hself.clone(): ActorHandle&lt;SpaServerMsg&gt;, remote_addr: SocketAddr =&gt; |data: &amp;MyData| {
                let data = ws_msg!( JS_MOD_PATH, data).to_json()?;
                let remote_addr = remote_addr.clone();
                Ok( hself.try_send_msg( SendWsMsg{remote_addr,data})? )
            });
            self.h_data_actor.send_msg( ExecSnapshotAction(action)).await?;
        }
        Ok(())
    }
<span class="boring">}</span></code></pre></pre>
<p>Since the <code>SpaService</code> needs to send a message to its <em>DataActor</em> this implies that a handle to the actor is stored in the
<code>SpaService</code>, usually from a <code>PreActorHandle</code> of the <em>DataActor</em> passed into the <code>SpaService</code> constructor.</p>
<p>Some <em>DataActors</em> have to obtain input from remote servers according to specific schedules hence there is a chance the first
clients are going to connect before the <em>DataActor</em> is ready. To avoid the overhead of creating, sending and executing superfluous
data actions and websocket messages we keep track of the <code>data_available</code> state of <em>DataActors</em> within the <code>SpaServer</code>. This works
by using a <code>init_action</code> field in the <em>DataActor</em> that has its actions executed once the data is initialized. The actor system
instantiation site (e.g. <code>main()</code>) then sets this action to send a <code>DataAvailable</code> message to the <code>SpaServer</code>, which passes it on
to matching <code>SpaServices</code> by calling their <code>data_available(..)</code> functions. Those functions can use the <em>DataActor</em> name and/or
the data type to determine if this is a relevant data source. If it is, and if the server already has connections, the <code>data_available()</code>
implementation sends a <code>DataRefAction</code> containing message to the <em>DataActor</em> just like in the <code>init_connection()</code> case above. The
<code>SpaServer</code> then stores the <code>data_available</code> status for that service, to be passed into subsequent <code>init_connection(..)</code> calls.</p>
<p>While the data availability tracking adds some overhead to both <em>DataActors</em> and <code>SpaService</code> implementations it is an effective
way to deal with the intrinsic race condition between connection requests and external data acquisition.</p>
<p>This leaves us with data updates, which are always initiated by the <em>DataActor</em>. When its internal data model changes the <em>DataActor</em>
executes a <code>DataAction</code> that is stored in one of its fields which is set from the actor system instantiation site (<code>main()</code>) to an
action that creates a JSON message from the updated data and sends it as a <code>BroadcastWsMsg</code> message to the <code>SpaServer</code>. The
server then distributes the JSON message over the websockets of all of its current connections.</p>
<h2 id="2-instantiating-the-web-application-actor-system"><a class="header" href="#2-instantiating-the-web-application-actor-system">2. Instantiating the Web Application Actor System</a></h2>
<p>What ties all this together is the site where we create the <code>SpaServices</code>, <em>DataActors</em> and the <code>SpaServer</code> - usually the <code>main()</code>
function of the application binary.</p>
<p>The following code is an example from the <a href="odin_server/../odin_sentinel/odin_sentinel.html"><code>odin_sentinel</code></a> crate. The <code>SentinelActor</code> takes
the <em>DataActor</em> role, The <code>SentinelService</code> is the associated <code>SpaService</code>.</p>
<p>We use a <code>PreActorHandle</code> for the <code>SentinelActor</code> (<em>DataActor</em>) since we need to pass it into the <code>SentinelService</code>
(<code>SpaService</code>) constructor, which is required to create the <code>SpaServer</code>, which is then in turn used to initialize the init/update
action fields when instantiating the <code>SentinelActor</code> (see <a href="odin_server/../odin_actor/actor_communication.html">actor communication</a> in
<code>odin_actor</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::any::type_name;
use odin_build;
use odin_actor::prelude::*;
use odin_server::prelude::*;
use odin_sentinel::{SentinelStore,SentinelUpdate,LiveSentinelConnector,SentinelActor,load_config, web::SentinelService};

run_actor_system!( actor_system =&gt; {

    let hsentinel = PreActorHandle::new( &amp;actor_system, "updater", 8);

    let hserver = spawn_actor!( actor_system, "server", SpaServer::new(
        odin_server::load_config("spa_server.ron")?,
        "sentinels",
        SpaServiceList::new()
            .add( build_service!( hsentinel.to_actor_handle() =&gt; SentinelService::new( hsentinel)))
    ))?;

    let _hsentinel = spawn_pre_actor!( actor_system, hsentinel, SentinelActor::new(
        LiveSentinelConnector::new( load_config( "sentinel.ron")?), 
        dataref_action!( hserver.clone(): ActorHandle&lt;SpaServerMsg&gt; =&gt; |_store: &amp;SentinelStore| {
            Ok( hserver.try_send_msg( DataAvailable{sender_id:"updater",data_type: type_name::&lt;SentinelStore&gt;()} )? )
        }),
        data_action!( hserver: ActorHandle&lt;SpaServerMsg&gt; =&gt; |update:SentinelUpdate| {
            let data = ws_msg!("odin_sentinel/odin_sentinel.js",update).to_json()?;
            Ok( hserver.try_send_msg( BroadcastWsMsg{data})? )
        }),
    ))?;
    
    Ok(())
});
<span class="boring">}</span></code></pre></pre>
<h2 id="3-client-interaction"><a class="header" href="#3-client-interaction">3. Client Interaction</a></h2>
<p>Please refer to the <a href="odin_server/client.html">Server-Client Interaction</a> section for details of how to write
client (browser side) code that interacts with the <code>SpaServer</code> and <code>SpaService</code> instances.</p>
<p>These clients are represented by Javascript modules (served as service specific <a href="odin_server/../odin_build/odin_build.html"><strong>assets</strong></a>) that do
direct DOM manipulation and use JSON message sent over websockets to communicate with the server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin-web-clientserver-interaction"><a class="header" href="#odin-web-clientserver-interaction">ODIN Web Client/Server Interaction</a></h1>
<p>The <code>SpaServer</code> and its <code>SpaServices</code> are only half of the story. Since they serve (static and dynamic) data
we still need to visualize and control the data on user machines. To avoid the need for any end-user install we
use standard HTTP, HTML, Javascript and JSON messages over websockets for this purpose.</p>
<p>While <code>SpaServer</code> and <code>SpaService</code> are generic and can be used for many different web pages/applications the
main end-user visualization we target is a single web page showing geospatial data in application specific layers.</p>
<img class="mono right" src="odin_server/../img/odin-ui.svg" width="40%"/>
<p>The four items within this UI are:</p>
<ul>
<li>icon box</li>
<li>UI windows (with UI components)</li>
<li>virtual globe</li>
<li>data entities</li>
</ul>
<p>The icon box contains icons that launch associated UI windows. There is an icon/window pair for each data layer
that can be displayed, plus some pairs for general functions such as clocks, settings and layer control.</p>
<img class="mono left" src="odin_server/../img/odin-ui-window.svg" width="20%"/>
<p>The UI windows serve a dual purpose: they can be used for alphanumeric display of data and they hold user interface
components to control what data is displayed and how it is rendered. UI windows normally contain vertically stacked,
expandable <em>panels</em> for different functional areas within the layer. Panels hold related <em>UI components</em></p>
<p>The windows are shown on top of a 3D virtual globe background that uses WebGL to render both static maps and
dynamic data entities such as track symbols or weather information. Data entities are geometric constructs
such as points, lines and polygons, or symbols/icons representing data items.</p>
<h3 id="31-dom"><a class="header" href="#31-dom">3.1 DOM</a></h3>
<p>The underlying DOM is assembled by <code>odin_server::SpaComponents::to_html()</code> based on the components that were collected
from each of the configured <code>SpaService</code> implementations of the application. It has the following structure:</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
        &lt;!-- collected head fragments  --&gt;
        &lt;link rel="stylesheet" type="text/css" href="./asset/odin_server/ui.css"/&gt;&gt;
        &lt;script type="module" src="./asset/odin_server/main.js"&gt;&lt;/script&gt;
        &lt;script type="module" src="./asset/odin_goesr/odin_goesr.js"&gt;&lt;/script&gt;
        ...
    &lt;/head&gt;

    &lt;body&gt;
        &lt;!-- collected body fragments  --&gt;
        &lt;div id="cesiumContainer" class="ui_full_window"&gt;&lt;/div&gt;
        ...

        &lt;!-- post init script  --&gt;
        &lt;script type="module"&gt;
            import * as main from './asset/odin_server/main.js';
            if (main.postInitialize) { main.postInitialize(); }
            import * as odin_goesr from './asset/odin_goesr/odin_goesr.js';
            if (odin_goesr.postInitialize) { odin_goesr.postInitialize(); }
            ...
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Head fragments can contain link elements (for CSS) and script elements (for JS scripts and modules).
This is collected from the <code>SpaService::add_components()</code> implementations of the configured services.
<code>SpaServices</code> normally have an associated JS module, stored in the <code>asset/</code> dir of the containing crate, e.g</p>
<pre><code>    odin_goesr/
      assets/
         odin_goesr_config.js       optional, if there is static config of odin_goesr.js
         odin_goesr.js              the JS module associated with the SpaService
      src/      ⬆︎         
         goesr_service.rs           the SpaService implementation that adds odin_goesr.js to the document
</code></pre>
<p>The first included JS module is always the automatically added <code>main.js</code>, which is provided as an asset by the
<code>odin_server</code> crate, there is no need to add it to <code>add_dependencies()</code> implementations of <code>SpaServices</code>. Its
main purpose is to define types and access APIs for data that can be shared between Javascript modules and users
(e.g. <code>GeoPoint</code>).</p>
<p>Please note <code>main.js</code> module only provides a local storing mechanism, i.e. if no other <code>SpaService</code> such as
<a href="odin_server/../odin_share/odin_share.html"><code>odin_share</code></a><code>::ShareService</code> is configured it will only allow to share data between micro
services (layers) running within the same browser document.</p>
<p>The document construction ensures that each configured JS module is loaded just once in the order of first reference as
odin-rs modules normally depend on each other (specified by their <code>SpaService::add_dependencies()</code> implementation).</p>
<p>Body fragments are not restricted and can contain whatever HTML elements are required by their <code>SpaServices</code>.</p>
<p>Following the body fragment section is a script that calls <code>postInitialize()</code> of each loaded JS module that contains
such a function. This is used for code that has to run after all modules have been initialized. Modules
might be async and hence we cannot rely on their static order to guarantee completed initializatin.</p>
<p>If <code>SpaService</code> impls do have dependencies and components such as JS modules those have to be
specified in the <code>SpaService</code> trait function, as shown in the <code>GoesrService</code> example below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl SpaService for GoesrService {

    fn add_dependencies (&amp;self, spa_builder: SpaServiceList) -&gt; SpaServiceList {
        spa_builder.add( build_service!( =&gt; CesiumService::new())) // recursive dependency graph
        ...
    }

    fn add_components (&amp;self, spa: &amp;mut SpaComponents) -&gt; OdinServerResult&lt;()&gt;  {
        spa.add_assets( self_crate!(), load_asset);          // all icons and other resources used by JS module
        spa.add_module( asset_uri!("odin_goesr_config.js")); // module with static config
        spa.add_module( asset_uri!( "odin_goesr.js" ));      // service specific JS module itself
        ...
        Ok(())
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="32-client-browser-code"><a class="header" href="#32-client-browser-code">3.2 Client (Browser) Code</a></h3>
<p>Although there is no need for a specific structure or purpose of a JS module the ones implementing UI windows
and websocket message processing follow the convention laid out in the <code>odin_goesr.js</code> example below:</p>
<pre><code class="language-javascript">
//--- 1. import JS module configuration
import { config } from "./odin_goesr_config.js";              // associated static config for this module

//--- 2. import other JS modules
import * as main from "../odin_server/main.js";               // global functions (e.g. for data sharing)
import * as util from "../odin_server/ui_util.js";            // common, cross-module support functions
import * as ui from "../odin_server/ui.js";                   // ODIN specific user interface library 
import * as ws from "../odin_server/ws.js";                   // websocket processing
import * as odinCesium from "../odin_cesium/odin_cesium.js";  // virtual globe rendering interface from odin_cesium
... 

//--- 3. constants
const MOD_PATH = "odin_goesr::goesr_service::GoesrService";   // the name of the associated odin-rs SpaService 
...

//--- 4. registering JS message handlers
ws.addWsHandler( MOD_PATH, handleWsMessages);                 // incoming websocket messages for MOD_PATH
main.addShareHandler( handleShareMessage);                    // if module uses shared data items
main.addSyncHandler( handleSyncMessage);                      // if module supports synchronization commands

//--- 5. data type definitions, module variable initialization
...
var dataSets = [];                                            // module data
var dataSetView = undefined;                                  // module global UI components
var selectedDataSet = undefined;                              // keeping track of user selections
...

//--- 6. UI initialization
createIcon();
createWindow();                                               // UI window definition
initDataSetView();                                            // initialize UI window components and store references
...

console.log("ui_cesium_goesr initialized");

//--- 7. function definitions
...
function createIcon() {                                       // define UI window icon (used to automatically populate icon box)
    return ui.Icon("./asset/odin_goesr/geo-sat-icon.svg", (e)=&gt; ui.toggleWindow(e,'goesr'));
}

function createWindow() {                                     // define UI window structure and layout
    return ui.Window("GOES-R Satellites", "goesr", "./asset/odin_goesr/geo-sat-icon.svg")(
        ui.LayerPanel("goesr", toggleShowGoesr),              // panel with module information (should be first)
        ...
        ui.Panel("data sets", true)(                          // (collapsible) panel definition
            ui.RowContainer()(
                ui.CheckBox("lock step", ...),
                ...
                (dataSetView = ui.List("goesr.dataSets", 6, selectGoesrDataSet)),
                ...
            )
        ),
        ...
        ui.Panel("layer parameters", false)(                 // panel with display parameter controls (should be last)
            ui.Slider("size [pix]", "goesr.pointSize", ...)
            ...
        )
    );
}

function initDataSetView() {                                 // UI component init 
    let view = ui.getList("goesr.dataSets");
    if (view) {
        ui.setListItemDisplayColumns(view, ["fit", "header"], [    // defines List columns and display
            { name: "sat", tip: "name of satellite", width: "3rem", attrs: [], map: e =&gt; e.sat.name },
            { name: "good", tip: "number of good pixels", width: "3rem", attrs: ["fixed", "alignRight"], map: e =&gt; e.nGood },
            ...
        ])
    }
}

function selectGoesrDataSet(event) {                         // UI component callback
    let ds = event.detail.curSelection;
    if (ds) {
        selectedDataSet = ds;                                // update selected items
        ...
    }
}

function handleWsMessages(msgType, msg) {
    switch (msgType) {
        case "hotspots": handleGoesrDataSet(msg); break;
        ...
    }
}

function handleGoesrDataSet (hotspots) {
    ...
    dataSets.push( hotspots);                                // update data
    ui.setListItems( dataSetView, displayDataSets);          // update UI components displaying data
    ...
}

function handleShareMessage (msg) {                          // shared data updates (local and between users)
    if (msg.setShared) {
        let sharedItem = msg.setShared; ...
    }
    ...
}

function handleSyncMessage (msg) {                           // user interface sync (between users)
    if (msg.updateCamera) { ... }
}
...                                                          // more module functions


//--- 8. global post JS module initialization
export function postInitialize() {                            // optional but needs to be named 'postInitialize`  
    ...
}
</code></pre>
<p>Not all JS modules need all these sections. All functions (except postInitialize) are module private and can be named
at will, although we encourage to use above conventions so that modules are more easy to read.</p>
<p>If a module requires static initialization that can change independently of the code this should go into a separate
<code>&lt;module-name&gt;_config.js</code> asset that is kept either outside the repository in the <code>ODIN_ROOT/asset/</code> directory tree or
(if it has sensible non-application specific defaults) in the respective <code>assets/</code> directory of the crate that provides
the service. Although there can be some code (and even imports) config modules should be restricted to exporting a
single <code>config</code> object like so:</p>
<pre><code class="language-javascript">export const config = {
    layer: {
      name: "/fire/detection/GOES-R",
      description: "GOES-R ABI Fire / Hotspot Characterization",
    },
    pointSize: 5,
    ...
}
</code></pre>
<p>The functions and UI components used by JS modules are from ODIN's own <a href="odin_server/odin_server/ui_library.html"><code>odin_server/assets/ui.js</code></a> library.
The main reason why we use our own is that most available 3rd party libraries are meant to be for full web pages whereas we
use UI components in floating windows on top of our main display - the virtual globe. This means we have to minimize screen
space for UI components. See <a href="odin_server/design_principles.html">design principles</a> for other reasons.</p>
<h3 id="33-websocket-message-processing"><a class="header" href="#33-websocket-message-processing">3.3 WebSocket Message Processing</a></h3>
<p>This leaves us the (bi-directional) processing of websocket messages, which is not hard-coded but implemented as a <code>SpaService</code> /
JS module pair itself: <code>odin_server::WsService</code> and <code>odin_server/assets/ws.js</code>.</p>
<p>As a general principle we only exchange JSON messages over the websocket. Each message uses the following JSON format:</p>
<pre><code>    { "mod": "&lt;service name&gt;", "&lt;msg-name&gt;": &lt;payload value&gt; }
</code></pre>
<p>(e.g. <code>{ "mod": "odin_goesr::GoesrService", "hotspots": [...] }</code> in the above example). The <code>mod</code> field is used on both the
server- and the client-side to filter/route it to its respective service/JS module, i.e. it effectively creates a service
specific namespace for messages.</p>
<h4 id="331-spaservice-websocket-handling"><a class="header" href="#331-spaservice-websocket-handling">3.3.1 <code>SpaService</code> websocket handling</a></h4>
<p>On the server side this entails a <code>SpaService::handle_ws_msg(..)</code> implementation for incoming messages (sent by the JS module):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SpaService for MyService {
    ...
    async fn handle_ws_msg (&amp;mut self, 
        hself: &amp;ActorHandle&lt;SpaServerMsg&gt;, remote_addr: &amp;SocketAddr, ws_msg_parts: &amp;WsMsgParts) -&gt; OdinServerResult&lt;WsMsgReaction&gt; 
    {
        if ws_msg_parts.mod_path == ShareService::mod_path() {
            match ws_msg_parts.msg_type {
                "myMessage" =&gt; ...
                ...
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>WsMsgParts</code> is a helper type that already breaks out the <code>mod_path</code>, <code>msg_type</code> and <code>payload</code> string slices of the incoming
message text.</p>
<p>Sending messages from the service to the client has to go through the <code>SpaServer</code>, i.e. is done by sending any one of the
following actor messages to it:</p>
<ul>
<li><code>BroadcastWsMsg</code> sends a websocket message to all currently connected (browser) clients</li>
<li><code>SendAllOthersWsMsg</code> sends to all but one (usually the sender client) websocket connection</li>
<li><code>SendGroupWsMsg</code> sends to a explicitly provided set of websocket connections</li>
<li><code>SendWsMsg</code> sends only to one explicitly specified websocket connection</li>
</ul>
<p>Each of these types store the websocket message as a generic <code>String</code> field, i.e. the message can be assembled manually. To
avoid mistakes and cut boiler plate code we provide a</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WsMsg&lt;T&gt;  {
    pub mod_path: &amp;'static str, // this is composed of crate_name/js_module (e.g. "odin_cesium/odin_cesium.js")
    pub msg_type: &amp;'static str, // the operation on the payload
    pub payload: T
}
<span class="boring">}</span></code></pre></pre>
<p>helper construct for serialization that can be used like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let msg = WsMsg::json(ShareService::mod_path(), "myMessage", payload)?;
   hserver.send_msg( BroadcastWsMsg{ data: msg}).await;
<span class="boring">}</span></code></pre></pre>
<p>The payload serialization/deserialization is usually done by means of the <a href="https://docs.rs/serde_json/latest/serde_json/"><code>serde_json</code></a> crate.</p>
<h4 id="332-js-module-websocket-processing"><a class="header" href="#332-js-module-websocket-processing">3.3.2 JS module websocket processing</a></h4>
<p>On the client (browser) side websocket messages come in through the <code>odin_server/assets/ws.js</code> JS module (if <code>odin_server::WsService</code> is used),
which is responsible for dispatching the message to the JS module that registered for the <code>mod</code> property of the message object.</p>
<p>JS module websocket handlers are functions that take two arguments - the name of the message (a string) and the Javascript object
that is deserialized from the payload value:</p>
<pre><code class="language-javascript">   function myHandler (msgTypeName, msgObj) {..}
</code></pre>
<p>This means deserialization if automatically done in ws.js - the receiving JS module does not have to call <code>JSON.parse(..)</code>.</p>
<p>The JS module recipient has to provide the message handler function and register it like so:</p>
<pre><code class="language-javascript">...
import * as ws from "../odin_server/ws.js";                  
...
const MOD_PATH = "odin_goesr::goesr_service::GoesrService";   // the type name of the corresponding SpaService implementation
...
ws.addWsHandler( MOD_PATH, handleWsMessages);
...
function handleWsMessages(msgType, msgObj) {
    switch (msgType) {
        case "hotspots": ...; break;
    }
}
</code></pre>
<h4 id="333-mainjs---shared-types-and-operations"><a class="header" href="#333-mainjs---shared-types-and-operations">3.3.3 main.js - shared types and operations</a></h4>
<p>The automatically included <code>main.js</code> module defines types and APIs for values that can be shared between JS modules (and potentially
with other users if a service such as <a href="odin_server/../odin_share/odin_share.html"><code>odin_share::ShareService</code></a> is included in the application).</p>
<p>JS modules using this functionality have to add a respective import:</p>
<pre><code class="language-javascript">...
import * as main from "../odin_server/main.js";
...
 ...main.getSharedItem(key)...
</code></pre>
<p>The shared types are</p>
<ul>
<li><code>GeoPoint</code> and <code>GeoPoint3</code> for 2- and 3-dimensional geographic coordinates</li>
<li><code>GeoLine</code> and <code>GeoLineString</code> for geographic polylines</li>
<li><code>LineString3</code> for <a href="https://en.wikipedia.org/wiki/Earth-centered,_Earth-fixed_coordinate_system">ECEF</a> (xyz) trajectories</li>
<li><code>GeoRect</code> for parallel/meridian aligned rectangles of geographic coordinates</li>
<li><code>GeoPolygon</code> for general geographic coordinate polygons</li>
<li><code>GeoCircle</code> and <code>GeoCylinder</code> for geographic circles and cylinders</li>
<li><code>String</code> for text data</li>
<li><code>I64</code> and <code>F64</code> for numeric integer and float values</li>
<li><code>Json</code> for text data that is supposed to be parsed as <a href="https://en.wikipedia.org/wiki/JSON">JSON</a>, i.e. is a
"catch-all" format for arbitrary objects</li>
</ul>
<p>Each of these types has a respective type name constant (e.g. <code>GEO_LINE</code>) that can be used to identify the type.</p>
<p>Instances of these types can be shared locally or globally, and are identified through an associated pathname (path elements
separated by '/'). The basic abstraction for this is the <code>SharedItem(key,isLocal,value)</code>. Shared values can be further
annotated by having a <code>comment</code> and an <code>owner</code>.</p>
<p>The abstract storage model for shared items is a general key/value store, i.e. <code>SharedItems</code> are identified through their
respective keys (pathnames).</p>
<p>The main API to access shared items is</p>
<ul>
<li><code>getSharedItem (key)</code> - to get a specific shared item with known key</li>
<li><code>getAllMatchingSharedItems (regex)</code> - to get a set of shared items through key patterns</li>
<li><code>setSharedItem (key, valType, data, isLocal=false, comment=null)</code> - to create, store and share a value</li>
<li><code>removeSharedItem(key)</code> - to purge a shared value from the store</li>
</ul>
<p>Changes to the shared item store are broadcasted to registered listeners, i.e. if a JS module needs to know of such
changes it has to register:</p>
<pre><code class="language-javascript">...
main.addShareHandler( handleShareMessage);
...
function handleShareMessage (msg) {
    if (msg.SHARE_INITIALIZED) {...} 
    else if (msg.setShared) {...}
    else if (msg.removeShared) {...}
}
</code></pre>
<p>The sharing mechanism can also be used to synchronize operations such as view changes between users. This is done through
<code>addSyncHandler( handleSyncMessage)</code> registration, respective <code>handleSyncMessage</code> handlers implementations and
<code>publichCmd(cmd)</code> calls for relevant state changes. Since those only make sense / have an effect in a context of a
remote service such as <code>ShareService</code> please refer to details in <a href="odin_server/../odin_share/odin_share.html"><code>odin_share</code></a>.</p>
<p><code>main.js</code> also includes a <code>addShareEditor (dataType, label, editorFunc)</code> function that can be used by JS modules to
register interactove editors for share types such as 'GeoLineString` but this is more of a specialty.</p>
<p>Apart from providing the basic sharing API and types <code>main.js</code> can also be used to define document global data through its
<code>exportFunctionToMain(f)</code> and <code>exportObjectToMain(o)</code> functions, which make their arguments globally available in the DOM
as <code>window.main.&lt;name&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin-web-client-user-interface-library"><a class="header" href="#odin-web-client-user-interface-library">ODIN Web Client User Interface Library</a></h1>
<p>TBD.</p>
<h2 id="widgets"><a class="header" href="#widgets">Widgets</a></h2>
<p><code>odin_server/assets/ui.js</code> provides the following UI components that are implemented as <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement">`HTMLElements</a></p>
<h4 id="window"><a class="header" href="#window">Window</a></h4>
<h4 id="icon"><a class="header" href="#icon">Icon</a></h4>
<h4 id="button"><a class="header" href="#button">Button</a></h4>
<h4 id="checkbox"><a class="header" href="#checkbox">CheckBox</a></h4>
<h4 id="radio"><a class="header" href="#radio">Radio</a></h4>
<h4 id="choice"><a class="header" href="#choice">Choice</a></h4>
<h4 id="slider"><a class="header" href="#slider">Slider</a></h4>
<h4 id="list"><a class="header" href="#list">List</a></h4>
<h4 id="treelist"><a class="header" href="#treelist">TreeList</a></h4>
<h4 id="label"><a class="header" href="#label">Label</a></h4>
<h4 id="field"><a class="header" href="#field">Field</a></h4>
<h4 id="textarea"><a class="header" href="#textarea">TextArea</a></h4>
<h4 id="popupmenu"><a class="header" href="#popupmenu">PopupMenu</a></h4>
<h4 id="rowcontainer-and-columncontainer"><a class="header" href="#rowcontainer-and-columncontainer">RowContainer and ColumnContainer</a></h4>
<h2 id="theme-support"><a class="header" href="#theme-support">Theme Support</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_cesium"><a class="header" href="#odin_cesium">odin_cesium</a></h1>
<p>This is a system crate that depends on [<code>odin_server</code>], providing <code>odin_server::SpaService</code> implementations that are related to using
<a href="https://cesium.com/platform/cesiumjs/">CesiumJS</a> for user interfaces (UI) on top of a virtual globe display. The crate provides two main
services:</p>
<ul>
<li><code>CesiumService</code> is responsible for providing the 3rd party CesiumJS code for the virtual globe rendering, and the
<code>odin-rs</code> specific user interface code that controls it. It also includes some general UI elements that are always
present (e.g. clock)</li>
<li><code>ImgLayerService</code> is a configurable service to provide and control background imagery from own and external (proxied) sources.
It is especially the layer that controls the map display</li>
</ul>
<p>Since CesiumJS is a large library we do support options for how it is accessed by the client. This can be either by</p>
<ul>
<li>directly downloading it from https://cesium.com/downloads/cesiumjs/releases/<version>/Build/Cesium,</li>
<li>proxying this URL with the <code>odin-rs</code> server</li>
<li>providing it as a static asset from <ODIN-ROOT>/assets/odin_cesium/cesiumjs</li>
</ul>
<p>Those alternatives are controlled by the Cargo features <code>cesium_external</code>, <code>cesium_proxy</code> and the default <code>cesium_asset</code>.</p>
<p>To obtain, strip and store the requires cesium assets in <code>&lt;ODIN-ROOT&gt;/odin_cesium/cesiumjs/</code> we provide the
<code>install_cesium</code> binary tool, which you can run like so: <code>cargo run --bin install_cesium -- --version=&lt;cesium-version&gt;</code></p>
<p>To see the current CesiumJS version please visit https://cesium.com/downloads/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_share"><a class="header" href="#odin_share">odin_share</a></h1>
<p>The <code>odin_share</code> system crate provides the means to share string labeled data between <a href="odin_share/../odin_actor/odin_actor.html">actors</a> and
<a href="odin_share/../odin_server/odin_server.html">micro services</a>. It therefore is also the basis for sharing interactively created data between users of
the same ODIN server.</p>
<p>The data model on which <code>odin_server</code> is built is a homogenous, statically typed key value store. Keys are path-like strings and the value type is the generic type parameter of the store. The basic abstraction is an object-safe <code>SharedStore&lt;T&gt;</code> trait that resembles the
interface of a standard <code>HashMap</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub trait SharedStore&lt;T&gt; : Send + Sync where T: SharedStoreValueConstraints {
        fn ref_iter&lt;'a&gt;(&amp;'a self)-&gt;Box&lt;dyn Iterator&lt;Item=(&amp;'a String,&amp;'a T)&gt; + 'a&gt;;
        fn clone_iter(&amp;self)-&gt;Box&lt;dyn Iterator&lt;Item=(String,T)&gt; + '_&gt;;

        fn insert(&amp;mut self, k: String, v: T)-&gt;Option&lt;T&gt;;
        fn remove (&amp;mut self, k: &amp;str)-&gt;Option&lt;T&gt;;
        fn get (&amp;self, k: &amp;str)-&gt;Option&lt;&amp;T&gt;;

        fn glob_ref_iter&lt;'a&gt;(&amp;'a self, glob_pattern: &amp;str)-&gt;Result&lt;Box&lt;dyn Iterator&lt;Item=(&amp;'a String,&amp;'a T)&gt; + 'a&gt;, OdinShareError&gt;;
        fn glob_clone_iter(&amp;self, glob_pattern: &amp;str)-&gt;Result&lt;Box&lt;dyn Iterator&lt;Item=(String,T)&gt; + '_&gt;, OdinShareError&gt;;
        ...
    }

    pub trait SharedStoreValueConstraints = Clone + Send + Sync + Debug + 'static + for&lt;'a&gt; Deserialize&lt;'a&gt; + Serialize;
<span class="boring">}</span></code></pre></pre>
<p>This resemblance is intentional - our general use case is a in-memory database of relatively few (&lt;1000&gt;) items, for which a
<code>std::collections::HashMap</code> is a valid choice. Apart from normal item getters/setters the primary operation is to iterate over store items.
Out of the box <code>odin_share</code> therefoer includes a <code>SharedStore</code> impl for <code>std::collections::HashMap</code>.</p>
<p>Persistency is supported by providing a <code>PersistentHashMapStore</code> struct that encapsulates a <code>HashMap</code> which is initialized from and
stored to a JSON file.</p>
<p>The abstraction should also support larger data sets that require disk storage, caches and query mechanisms. Since our data model
is simple we constrain queries to <a href="https://en.wikipedia.org/wiki/Glob_(programming)">glob pattern searches</a> which are supported by the specialized <code>glob_.._iter()</code> iterators.</p>
<p><code>SharedStoreValueConstraints</code> reflects the need to serialize/deserialize store content, send items as messages and to use store trait objects
from async code.</p>
<h2 id="server-side-sharedstore-sharing-via-sharedstoreactor"><a class="header" href="#server-side-sharedstore-sharing-via-sharedstoreactor">Server-side <code>SharedStore</code> sharing via <code>SharedStoreActor</code></a></h2>
<p>How do we use a <code>SharedStore</code> within an ODIN server? While <code>SharedStore</code> implementors could be global they are inherently mutable
and hence a global store would require locking patterns such as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::sync::{LazyLock,RwLock};
    ...
    static MY_STORE: LazyLock&lt;RwLock&lt;MyStore&gt;&gt; = ...
<span class="boring">}</span></code></pre></pre>
<p>Moreover, since the shared-ness is a critical aspect we also require a notification mechanism that allows callbacks on mutable clients
once a store changes, which makes the use of global objects quite unwieldy (especially in an <code>async</code> context). Hence our primary
use of <code>SharedStore</code> instances is the <a href="odin_share/../odin_actor/odin_actor.html">actor</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SharedStoreActor&lt;T,S,A&gt; where T: SharedStoreValueConstraints, S: SharedStore&lt;T&gt;, A: DataAction&lt;SharedStoreChange&lt;T&gt;&gt; {
    store: S,
    change_action: A,
    ...
}

define_actor_msg_set! { pub SharedStoreActorMsg&lt;T&gt; where T: SharedStoreValueConstraints = 
    SetSharedStoreValue&lt;T&gt; | RemoveSharedStoreValue | Query&lt;String,Option&lt;T&gt;&gt; | ExecSnapshotAction&lt;T&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>To make the <code>SharedStoreActor</code> type re-usable across different application domains we parameterize it not only with the store item type <code>T</code>, the store type <code>S</code> but also with a generic <a href="odin_share/../odin_action/odin_action.html">odin action</a> type <code>A</code> of a actor constructor parameter
which defines the "callback" actions to be performed when the store changes. Upon store mutation this <code>odin_action::DataAction</code> is
executed with a</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SharedStoreChange&lt;T&gt; where T: SharedStoreValueConstraints {
    Set { hstore: ActorHandle&lt;SharedStoreActorMsg&lt;T&gt;&gt;, key: String },
    Remove { hstore: ActorHandle&lt;SharedStoreActorMsg&lt;T&gt;&gt;, key: String },
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>parameter which can be sent to other actors. Recipients of such <code>SharedStoreChange</code> messages can then use its <code>hstore</code> actor handle
to query the changed store values by sending a <code>Query&lt;String,Option&lt;T&gt;&gt;</code> query message to the store actor, or by sending a</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct ExecSnapshotAction&lt;T&gt;( pub DynSharedStoreAction&lt;T&gt; )
<span class="boring">}</span></code></pre></pre>
<p>message to the store with an action trait object that will be executed by the store with its own <code>SharedStore&lt;T&gt;</code> trait object parameter.
These patterns look like so in a client actor using the store:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use odin_actor::prelude::*;
use odin_share::prelude::*;

enum StoreItem {...}

struct Client {...}

#[derive(Debug)] struct SomeClientMsg (ActorHandle&lt;SharedStoreActorMsg&lt;StoreItem&gt;&gt;);
define_actor_msg_set! { ClientMsg = SharedStoreChange&lt;StoreItem&gt; | SomeClientMsg }

impl_actor! { match msg for Actor&lt;Client,ClientMsg&gt; as
    SharedStoreChange&lt;StoreItem&gt; =&gt; cont! { // store has changed, query value
        match msg {
            SharedStoreChange::Set{ hstore, key } =&gt; {
                println!("client received update for key: {:?}, now querying value..", key);
                match timeout_query_ref( &amp;hstore, key, secs(1)).await {
                    Ok(response) =&gt; match response {
                        Some( value ) =&gt; ...
                    }
                }
            }
            ...
        }
    }
    ...
    SomeClientMsg =&gt; cont! { // iterate over store items
        let action = dyn_shared_store_action!( =&gt; |store as &amp;dyn SharedStore&lt;StoreItem&gt;| {
            for (k,v) in store.ref_iter() {
                ... // process key-value items
            }
            Ok(())
        });
        msg.0.send_msg( ExecSnapshotAction(action)).await;
    }
}   
<span class="boring">}</span></code></pre></pre>
<p>The actor system construction in turn uses the change action to register clients in the store:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use odin_actor::prelude::*;
use odin_share::prelude::*;

run_actor_system!( asys =&gt; {
    let client = PreActorHandle::new( &amp;asys, "client", 8); 

    let hstore = spawn_actor!( asys, "store", SharedStoreActor::new(
        HashMap::new(),
        data_action!( let client: ActorHandle&lt;ClientMsg&gt; = client.to_actor_handle() =&gt; 
            |update: SharedStoreChange&lt;StoreItem&gt;| Ok( client.try_send_msg( update)? )
        )
    ))?;
    ...
    let client = spawn_pre_actor!( asys, client, Client::new(...))?;
    ...
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>See the <code>enum_store.rs</code> example for further details.</p>
<h2 id="abstract-sharing-model"><a class="header" href="#abstract-sharing-model">Abstract Sharing Model</a></h2>
<p>TODO - explain SharedItem (pathname keys), owner, role, subscription</p>
<h2 id="client-side-sharedstore-sharing-via-shareservice"><a class="header" href="#client-side-sharedstore-sharing-via-shareservice">Client-side <code>SharedStore</code> sharing via <code>ShareService</code></a></h2>
<p>While the previous section was about how to use <code>SharedStore</code> between components (actors) <em>within</em> an ODIN server, we
also use this mechanism to share interactively entered data between <em>users</em> of such an ODIN server. Technically this means
we need to provide a <a href="odin_share/../odin_server/odin_server.html"><code>odin_server::SpaService</code></a> implementation that updates store values
through incoming websocket message handlers and distributes the store changes to other users through outgoing websocket
messages, which are then distributed on the client side to respective <code>SpaService</code> Javascript modules. This is the
purpose of <code>ShareService</code> and its associated <code>odin_share.js</code> Javascript module asset, which in turn depends on and
extends the general <code>main.js</code> module provided by <a href="odin_share/../odin_server/client.html"><code>odin_server</code></a>.</p>
<p>In addition to the sharing data values <code>SharedStore</code> also supports synchronizing operations between users. It is important
to note this is not unidirectional like screen sharing in video conferencing but allows to perform certain actions such as
view selection remotely. Although such actions are confined to the browser sandbox this is of course security relevant and hence
only takes place if the user explicitly allows it and specifies from whom such shared commands are accepted. This is based
on the <em>role</em> concept - if not already taken a user can identify/register for a role and then - separately - choose to
publish under that role. Other users will automatically see new roles (with their publishing status) and then - through
opt-in - subscribe to certain roles, at which point they will receive published commands from that role. A user can
register for multiple roles.</p>
<p>It is up to the JS modules of respective <code>SpaServices</code> which sync commands they support, both incoming through</p>
<pre><code class="language-javascript">import * as main from "../odin_server/main.js";
...
main.addSyncHandler( handleSyncMessage);
...
function handleSyncMessage (msg) {
    if (msg.updateCamera) {...} // example: reaction to remote view changes (if subscribed)
    ...
}
</code></pre>
<p>or outgoing through</p>
<pre><code class="language-javascript">   ... 
   main.publishCmd( { updateCamera: {lon, lat, alt} });  // example: execute view change remotely (if publishing)
   ...
</code></pre>
<p>The general API for synchronized operations is provided by <a href="odin_share/../odin_server/client.html">`main.js</a> and consists of the
following functions:</p>
<ul>
<li><code>requestRole (role)</code> - try to obtain a role (will fail if already registered on the server)</li>
<li><code>releaseRole (role)</code> - the converse (will fail if this is not an own role)</li>
<li><code>publishRole (role, isPublishing)</code> - start/stop publishing under specified role</li>
<li><code>subscribeToExtRole (role, isSubscribed)</code> - start/end subscription to an external role</li>
<li><code>publishCmd (cmd)</code> - send command to other users if there is a publishing own role and at least one remote subscriber</li>
</ul>
<p>Only <code>publishCmd</code> is used by general JS modules, all other functions are just for speciality modules such as <code>odin_share.js</code>
that implement remote sharing (normally through a dedicated UI).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_dem"><a class="header" href="#odin_dem">odin_dem</a></h1>
<p>The <code>odin_dem</code> crate is a system crate that provides a <a href="https://en.wikipedia.org/wiki/Digital_elevation_model">digital elevation model (DEM)</a>.
This crate is basically just a wrapper around the virtual <a href="https://gdal.org/en/latest/drivers/raster/vrt.html">GDAL VRT</a> driver that is
used to extract elevation data sets for given rectangular bounding boxes from a large mosaic.</p>
<h2 id="1-obtaining-and-building-the-dem-vrt"><a class="header" href="#1-obtaining-and-building-the-dem-vrt">1. Obtaining and Building the DEM VRT</a></h2>
<p>Prior to using this crate you have to obtain respective source DEM image tiles, e.g. from
https://apps.nationalmap.gov/downloader. Be aware that such data sets can be large (<a href="https://www.usgs.gov/3d-elevation-program">3dep</a> 1/3 arc
sec data for CONUS takes about 300 GB of disk space). The <code>odin_dem</code> crate provides the <code>fetch_dem_files</code> tool to download a file list of tiles
via HTTP but this can also be done through publicly available 3rd party tools.</p>
<p>DEM data is available from several servers such as</p>
<ul>
<li>https://apps.nationalmap.gov/downloader</li>
<li>https://earthexplorer.usgs.gov/</li>
<li>https://opendap.cr.usgs.gov/opendap/hyrax/SRTMGL1_NC.003/N00E006.SRTMGL1_NC.ncml.dmr.html</li>
</ul>
<p>We do provide sample file list for standard areas in the <code>resource/</code> directory of this crate but be advised that such data
might change - you should retrieve your own DEM tiles from the above sites.</p>
<p>Once the DEM tiles have been retrieved the <a href="https://gdal.org/en/latest/programs/gdalbuildvrt.html">GDAL <code>gdalbuildvrt</code></a> tool has to be
used to create a <code>*.vrt</code> file from the downloaded DEM tiles. This <code>*.vrt</code> file is the basis for extracting the DEM for regions
of interest such as incident areas, either as a synchronous function from within an existing server or through a simple standalong
<a href="odin_dem/../intro.html#edge_servers">edge server</a>.</p>
<p>Manual steps to retrieve tiles and build the VRT using the publicly available</p>
<ul>
<li><a href="https://www.gnu.org/software/wget/manual/wget.html">GNU <code>wget</code></a></li>
<li><a href="https://gdal.org/en/latest/programs/gdalbuildvrt.html">GDAL <code>gdalbuildvrt</code></a></li>
</ul>
<p>cross-platform command line tools are:</p>
<pre><code class="language-shell">$&gt; wget -nv -i &lt;file-list&gt;
$&gt; gdalbuildvrt &lt;region-name&gt;.vrt *.tif
</code></pre>
<h2 id="2-dem-extraction"><a class="header" href="#2-dem-extraction">2. DEM extraction</a></h2>
<p>The basic function of <code>odin_dem</code> is the synchronous</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_dem (bbox: &amp;BoundingBox&lt;f64&gt;, srs: DemSRS, img_type: DemImgType, vrt_file: &amp;str) -&gt; Result&lt;(String,File)&gt;
<span class="boring">}</span></code></pre></pre>
<p>which takes the target <a href="https://en.wikipedia.org/wiki/Spatial_reference_system">Spatial Reference System (SRS)</a>, the
bounding box (in SRS coordinates), the required result image type and the path to the <code>*.vrt</code> file (mosaic directory) to
use and returns a <code>std::fs::File</code> of the extracted DEM.</p>
<p>This function can be called synchronously (no async operation involved) but - depending on the size of the VRT and/or the
DEM to retrieve - it can take up to several seconds to execute.</p>
<p>The <code>get_dem</code> command line tool is a simple wrapper around this function.</p>
<h2 id="3-serving-a-dem"><a class="header" href="#3-serving-a-dem">3. Serving a DEM</a></h2>
<p>Since the underlying DEM data for this crate does require large amounts of disk space we provide a simple stand alone
<a href="odin_dem/../intro.html#edge_servers">edge server</a> to run on dedicated machinery. This edge server needs to be configured
with the path of the <code>*.vrt</code> file that references the tile data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_gdal"><a class="header" href="#odin_gdal"><code>odin_gdal</code></a></h1>
<p><a href="https://gdal.org/en/stable/index.html">GDAL</a> is the prevalent native (<code>odin-rs</code>-external) library to read, translate and modify geospatial data sets, supporting a wide range of formats (NetCDF, hdf5, tiff, png, jpeg, webp and many more). It is one of the key dependencies of <code>odin-rs</code>.</p>
<p>The role of <code>odin_gdal</code> is to simplify import and use of this complex library by means of adding utility functions and tools on top of
the underlying <a href="https://crates.io/crates/gdal">gdal</a> crate that does the linking to the native gdal libraries.</p>
<h3 id="building-gdal-from-source"><a class="header" href="#building-gdal-from-source">Building GDAL from Source</a></h3>
<p>Although it is recommended to install GDAL through native platform package managers it is possible to build from source, which
is available on https://github.com/OSGeo/gdal.git an documented <a href="https://gdal.org/en/stable/development/building_from_source.html">here</a>.</p>
<p>You can either build a shared or a static gdal library, but keep in mind that a static build requires to add - depending on build configuration -
all referenced sub-dependencies (tiff, netcdf, hdf5, jpeg etc.). This can be a daunting task.</p>
<p>The procedure to do a shared library build follows this scheme:</p>
<pre><code class="language-shell">mkdir ~/opt
cd ~/opt
git clone https://github.com/OSGeo/gdal.git
...
cd gdal
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_PYTHON_BINDINGS=OFF -DBUILD_JAVA_BINDINGS=OFF -DBUILD_APPS=OFF -DCMAKE_INSTALL_PREFIX=install ..
...
cmake --build .
...
cmake --build . --target install
...
</code></pre>
<p>Depending on the native package management that was used for installing GDAL dependencies you might have to add cmake build opts such
as <code>-DCMAKE_CXX_FLAGS="-I/opt/homebrew/include</code>.</p>
<p>To use the library in your <code>odin-rs</code> builds you need to set respective environment variables:</p>
<pre><code class="language-shell">export GDAL_VERSION=...
export GDAL_HOME=$HOME/opt/gdal/build/install # based on example above - adapt to your install location
export DYLD_LIBRARY_PATH=$GDAL_HOME/lib
</code></pre>
<p>Since we change an external library it is recommended to run <code>cargo clean</code> before any subsequent <code>cargo build</code> or <code>cargo run</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-domain-crates"><a class="header" href="#application-domain-crates">Application Domain Crates</a></h1>
<p>ODIN comes with a set of application domain crates that can be used as</p>
<ul>
<li>readily available building blocks for user specific applications</li>
<li>examples of how to add new data sources</li>
</ul>
<p>The following crates are currently included</p>
<ul>
<li><a href="odin_hrrr/odin_hrrr.html">odin_hrrr</a> - download of NOAA HRRR weather forecast data</li>
<li><a href="odin_goesr/odin_goesr.html">odin_goesr</a> - download and display of NOAA geostationary satellite hotspot data</li>
<li><a href="odin_sentinel/odin_sentinel.html">odin_sentinel</a> - Delphire Inc. smart fire sensor integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_hrrr"><a class="header" href="#odin_hrrr">odin_hrrr</a></h1>
<p>The <code>odin_hrrr</code> crate is an application domain crate to automatically download NOAA
<a href="https://rapidrefresh.noaa.gov/hrrr/">High Resolution Rapid Refresh(HRRR)</a> weather forecast data.
HRRR provides a rolling forecast with a 3km grid for both CONUS and Alaska that is updated every hour, each with a fixed
number of separate hourly forecast steps. HRRR data is distributed in the
<a href="https://old.wmo.int/extranet/pages/prog/www/WMOCodes/Guides/GRIB/GRIB2_062006.pdf">GRIB2</a> gridded binary format, i.e.
it is not readily available for display purposes - it is generally input for complex functions such as computing local
wind predictions, which therefore require timely updates once new forecast steps become available.</p>
<p>This crate mostly provides the functions to download HRRR data sets for specific areas and times, including periodic
download of live forecast data as it becomes available from the
<a href="https://nomads.ncep.noaa.gov/pub/data/nccf/com/hrrr/prod">NOAA HRRR server</a>.</p>
<p>Since HRRR data sets can be large and retrieval might require high bandwidth the <code>odin_hrrr</code> crate is primarily intended
for building <a href="odin_hrrr/../intro.html#edge-servers"><em>edge servers</em></a>.</p>
<h2 id="1-hrrr-schedules"><a class="header" href="#1-hrrr-schedules">1. HRRR Schedules</a></h2>
<p>If continuously downloaded this can be a lot of data - depending on required HRRR variables each forecast file can be ~0.8Gb
for conus. Moreover, there is a slightly varying delay of about 50min until the first forecast step for an hour becomes
available, and the following 18 forecast steps are each staggered by about 1-2min. Extended forecasts with 49 steps are
computed at fixed forecast hours (0am, 6am, 12pm, 18pm).</p>
<p>HRRR reports are generated each hour for a range of fixed forecast hours (each forecast hour is distributed as a
separate file). We call the set of all forecast files for a given hour a '<em>forecast cycle</em>', and the hour for which this
cycle is the '<em>base hour</em>'. Base hours 0am, 6am, 12pm, 18pm are extended cycles covering 0..=48h (=number of forecast files to
retrieve), all other (regular) cycles cover 0..=18h.</p>
<pre><code>     Bi   : base hour i (cycle base)
     s[j] : minutes since base hour for forecast step j availability (j: 0..=18 for regular, 0..=48 for extended)
     ◻︎    : forecast data set for t = Bi+s[j]
     
                   Bi                     Bi+1                   Bi+2
                   │0              s[0]   │60        s[N]        │120 
     cycle i-1 ...◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎       ┊     │           ┊          │
                   │                ┊     │  cycle i  ┊          │
                   │                ◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎          │
                   │    dm &lt; s[0]   ┊ s[0]&lt;= dm &lt;=s[N]┊   dm &gt; S[N]
                   │                      |                ◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎... cycle i+1
                   ├──────────────────────|────&gt;T                │
                                    dm: minutes(T) + 60
</code></pre>
<p>File availability within a cycle is staggered. It currently (as of Oct 2024) takes about 50min from base hour until the
first step of a forecast cycle becomes available. Each consecutive forecast step takes about 2min for regular cycles and
1min for extended cycles. We assume that cycles can be processed sequentially.</p>
<p>Schedules can be either estimated from a given <code>HrrrConfig</code> (config file) or computed by parsing the directory listing from the
NOAA server <sup class="footnote-reference"><a href="#3">1</a></sup> which has directories for the current and past day (this might be brittle since the HTML directory listing
format on the NOAA server can change). <code>HrrrConfig</code> files have the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>HrrrConfig(
    region: "conus",
    url: "https://nomads.ncep.noaa.gov/cgi-bin/filter_hrrr_2d.pl",
    dir_url_pattern: "https://nomads.ncep.noaa.gov/pub/data/nccf/com/hrrr/prod/hrrr.${yyyyMMdd}/conus",

    // estimated schedules if we don't want to compute them from NOAA server directory listings
    reg_first: 48,
    reg_last: 84,
    reg_len: 19,

    ext_first: 48,
    ext_last: 108,
    ext_len: 49,

    delay: Duration(secs:60,nanos:0), // extra time added to each computed schedule minute

    check_interval: Duration(secs:30,nanos:0), // interval in which we check availability of new forecast steps
    retry_delay: Duration(secs:30,nanos:0), // how long to wait between consecutive attempts for not-yet-available files
    max_retry: 4, // how many times do we try to download not-yet-available files
    max_age: Duration(secs:21600,nanos:0), // how long to keep downloaded files (6h)
)
<span class="boring">}</span></code></pre></pre>
<h2 id="2-forecast-data-and-queries"><a class="header" href="#2-forecast-data-and-queries">2. Forecast Data and Queries</a></h2>
<p>HRRR forecasts do provide some 90 variables and about 50 altitude/atmospheric levels. This means full grib2 files for CONUS can
be &gt;700 MB for each forecast step, of which there are at least 19 per hour. Continuously downloading this amount of data might
overwhelm some ODIN applications/servers.</p>
<p>HRRR does support <a href="https://nomads.ncep.noaa.gov/gribfilter.php?ds=hrrr_2d">queries for variable subsets and region boundaries</a>. This
can be used to reduce application specific forecasts with a limited number of variables (e.g. temperature, cloud cover, u/v- wind)
for medium sized incident areas (~50x50mi) to about 3.5 MB.</p>
<p>We therefore support configuration of both variables and regions of interest through the <code>HrrrDataSetConfig</code> struct, which can be
serialized/deserialized like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>HrrrDataSetConfig(
    name: "BigSur",
    bbox: GeoBoundingBox(
        west: LonAngle(-122.043),
        south: LatAngle(35.99),
        east: LonAngle(-121.231),
        north: LatAngle(36.594)
    ),
    fields: ["TCDC", "TMP", "UGRD", "VGRD"],
    levels: ["lev_2_m_above_ground", "lev_10_m_above_ground", "lev_entire_atmosphere"],
)
<span class="boring">}</span></code></pre></pre>
<p>The <code>HrrrActor</code> supports multiple simultaneous regions of interest. Downloaded
<a href="https://old.wmo.int/extranet/pages/prog/www/WMOCodes/Guides/GRIB/GRIB2_062006.pdf"><code>grib2</code></a> files are stored as they are received
from the NOAA server in <code>&lt;ODIN-root&gt;/cache/hrrr/hrrr-wrfsfcf-&lt;region&gt;-&lt;subregion-name&gt;-&lt;date&gt;-&lt;base-hour&gt;+&lt;forecast-step&gt;.grib2 (e.g. </code>.../hrrr-wrfsfcf-conus-bigsur-20241019-13+16.grib2`).</p>
<p>General parameters such as NOAA server URLs and maximum age of cached files can be configured with the <code>HrrrConfig</code>
struct mentioned above. All configuration is supported by the <a href="odin_hrrr/../odin_build/odin_build.html"><code>odin_build</code></a> crate, i.e.
respective serialized (<code>*.ron</code>) files can be inlined or looked up from <code>&lt;ODIN-root&gt;</code> directories or the source
repository.</p>
<h2 id="3-crate-functions"><a class="header" href="#3-crate-functions">3. Crate Functions</a></h2>
<p>The <code>odin_hrrr</code> crate can be used from within or outside of <a href="odin_hrrr/../odin_actor/odin_actor.html"><code>odin_actor</code> actor systems</a>. The basic
functions are</p>
<ul>
<li>one-time download of complete sets of most recent forecasts for a given time and <code>HrrrDataSetConfig</code></li>
<li>periodic download of forecast steps for given <code>HrrrDataSetConfig</code> lists as they become available from the NOAA server</li>
</ul>
<h3 id="31-one-time-download-of-available-forecasts"><a class="header" href="#31-one-time-download-of-available-forecasts">3.1 One-Time Download of Available Forecasts</a></h3>
<p>The purpose of this function is to obtain all most recently updated (available) forecast steps for a given time point.
Forecast hours of cycles overlap (T(Bi + j) == T(Bi-1 + j+1)) but we only retrieve the step from the last cycle that
covered the forecast hour.</p>
<p>Since every 6h we get an extended forecast cycle that covers 0..=48 forecast hours this means we have to retrieve
forecast steps from up to 3 cycles:</p>
<pre><code>     ◻︎ : obsolete available forecast step (updated by subsequent cycle)
     ◼︎ : relevant available forecast to retrieve (most up-to-date forecast for base + step)
     ○ : not-yet-available forecast step
   
     ◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎  (3) last ext cycle
                          ▲
      ◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎ ┊
                          ┊
       ◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◼︎◼︎◼︎                                    (2) last cycle: always completely available
                       ▲
        ◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎○○○○                                   (1) current cycle: might only be partially available
</code></pre>
<p>This function is normally used when a new <code>HrrrDataSetRequest</code> is made, i.e. it is a one-time call per data set.
It is mostly implemented in the <code>queue_available_forecasts(..)</code> function.</p>
<h3 id="32-periodic-download-of-forecasts"><a class="header" href="#32-periodic-download-of-forecasts">3.2 Periodic Download of Forecasts</a></h3>
<p>Since HRRR schedules are non-trivial and ODIN is primarily used to continuously and timely process data as it becomes
available this is the main function of the <code>odin_hrrr</code> crate.</p>
<p>Periodic download of HRRR forecast data sets is an async function that has to run in its own task, which is created
by <code>odin_hrrr::spawn_download_task &lt;A:DataAction&lt;HrrrFileAvailable&gt;&gt;(config: Arc&lt;HrrrConfig&gt;, cache_dir: PathBuf, action: A)</code>.
The <code>action</code> parameter (see <a href="odin_hrrr/../odin_action/odin_action.html">odin_action</a>) is what makes this function generic - it specifies
the async callback to be executed once a forecast step file has been fully downloaded by the task.</p>
<p>This task is automatically spawned from within a <code>HrrrActor</code> or from within the async <code>odin_hrrr::run_downloads(..)</code> function if
an edge server does not want to use a dedicated <code>HrrrActor</code> (see <code>get_hrrr.rs</code> binary). Dynamically adding/removing
<code>HrrrDataSetRequests</code> requires the actor. The task has its own request queue - it does not schedule new forecast steps itself
but depends on the application context (e.g. the <code>HrrrActor</code>) to do so, which is based on the HRRR schedule mentioned above.</p>
<p>As an auxiliary function the task also removes old HRRR data files according to the <code>max_age</code> value of the provided <code>HrrrConfig</code>,
i.e. it has to ensure disk space remains bounded.</p>
<h2 id="4-applications"><a class="header" href="#4-applications">4. Applications</a></h2>
<p>An simple actor application that just prints out notifications for each downloaded HRRR file looks like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use odin_common::define_cli;
use odin_actor::prelude::*;
use odin_hrrr::{load_config,HrrrActor, AddDataSet, HrrrConfig, schedule::{HrrrSchedules,get_schedules}, HrrrDataSetRequest, HrrrDataSetConfig, HrrrFileAvailable};

define_cli! { ARGS [about="NOAA HRRR download example using HrrrActor"] =
    hrrr_config: String [help="filename of HRRR config file", short,long,default_value="hrrr_conus.ron"],
    statistic_schedules: bool [help="compute schedules of available forecast files from server dir listing", short, long],
    ds_config: String [help="filename of HrrrDataSetConfig file"]
}

run_actor_system!( actor_system =&gt; {
    let hrrr_config: HrrrConfig = load_config( &amp;ARGS.hrrr_config)?;
    let schedules: HrrrSchedules = get_schedules( &amp;hrrr_config, ARGS.statistic_schedules).await?;
    let ds: HrrrDataSetConfig = load_config( &amp;ARGS.ds_config)?;
    let req = Arc::new(HrrrDataSetRequest::new(ds));
    
    let himporter = spawn_actor!( actor_system, "hrrr_importer", HrrrActor::new(
        hrrr_config,
        schedules,
        data_action!( =&gt; |data: HrrrFileAvailable| {
            println!("file available: {:?}", data.path.file_name().unwrap());
            Ok(())
        })
    ))?;

    actor_system.start_all().await?;
    himporter.send_msg( AddDataSet(req)).await?;
    actor_system.process_requests().await?;

    Ok(())
});
<span class="boring">}</span></code></pre></pre>
<h2 id="references"><a class="header" href="#references">References:</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">2</sup>
<p>https://nomads.ncep.noaa.gov/ - available data products</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">3</sup>
<p>https://nomads.ncep.noaa.gov/gribfilter.php?ds=hrrr_2d - HRRR queries</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">1</sup>
<p>https://nomads.ncep.noaa.gov/pub/data/nccf/com/hrrr/prod/ - HRRR download directories</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_sentinel"><a class="header" href="#odin_sentinel">odin_sentinel</a></h1>
<p>The <code>odin_sentinel</code> crate is a user (data) crate for retrieval, realtime import and processing of <a href="https://delphiretech.com/products/">Delphire
Sentinel</a> fire sensor data. Sentinel sensor devices are smart in-field devices that
use on-board AI to detect fire and/or smoke from a mix of sensor data such as visual/infrared cameras and chemical
sensors. The goal is to minimize latency for fire detection <em>and</em> in-field communication related power consumption.</p>
<p>The <code>odin_sentinel</code> crate accesses respective Sentinel data through an external Delphire server, it does not directly communicate with in-field devices. This external server provides two communication channels:</p>
<ul>
<li>an http query api to retrieve device capabilities and sensor record data</li>
<li>a websocket based push notification for new record data availability</li>
</ul>
<p>The primary component running in the ODIN server is a <code>SentinelActor</code>, which is a realtime database of a configurable
number of most recent sentinel sensor records. The <code>SentinelActor</code> does not directly communicate with the outside world - it
uses a <code>SentinelConnector</code> trait object to do external IO. The primary impl for this trait is the <code>LiveSentinelConnector</code>,
which retrieves the list of available Sentinel devices, queries each devices sensors and retrieves initial sensor records
(all using HTTP GET requests). It then opens a websocket and listens for incoming sensor record availability notifications
(as JSON messages). Once such a notification was received the connector uses HTTP GET to retrieve the record itself and
informs client actors about the update.</p>
<pre><code>                                                                                        [sentinel_alarm.ron] config
                                                               ┌─────────────────────────────────────╎─────┐                  
                                                               │ ODIN Server           ┌─────────────╎───┐ │                  
                                                               │                       │ AlarmActor  ╎   │ │                  
                                                 - devices     │                ┌─────▶︎│  ┌──────────▼┐  │ │                  
                                                 - sensors     │                │      │  │Alarm      ├─┐│ │                  
                            ┌─────────────────┐  - sensor-     │ ┌──────────────┴──┐   │  │ Messenger │ │────────▶︎ phone      
┌────────┐                  │ Delphire Server │     records    │ │ SentinelActor   │   │  └┬──────────┘ ││ │                
|        ├─┐                │                 │                │ │ ┌─────────────┐ │   │   └────────────┘│ │                  
│Sentinel│ │─ satellite ───▶︎│  ┌───────────┐  ├───── http ────────▶︎│             │ │   └─────────────────┘ │                  
│        │ │      or        │  │  record   │  │                │ │ │LiveConnector│ │                       │                  
└┬───────┘ │── cellular ───▶︎│  │ database  │  ├─── websocket ─────▶︎│             │ │   ┌─────────────────┐ │                  
 └─────────┘                │  └───────────┘  │                │ │ └─▲───────────┘ │   │ WebServerActor  │ │                  
                            │                 │ - notification │ └───╎──────────┬──┘   │ ┌────────────┐  │ │                  
                            └─────────────────┘                │     ╎          │      │ │  Sentinel  ├─┐│ │                  
                                                               │     ╎          └─────▶︎│ │   Service  │ │────────▶︎ web        
                                                               │     ╎                 │ └┬──────▲────┘ ││ │     browser      
                                            [sentinel.ron]╶╶╶╶╶╶╶╶╶╶╶┘                 │  └──────╎──────┘│ │                  
                                              config           │                       └─────────╎───────┘ │                  
                                                               └─────────────────────────────────╎─────────┘ 
                                                                                          [odin_sentinel.json] asset                 
</code></pre>
<p>Although <code>SentinelActor</code> can be connected to any client actor using <code>odin_action</code> for message interactions the <code>odin_sentinel</code> crate
includes two primary clients / client-components: <code>SentinelAlarmActor</code> and <code>SentinelSpaService</code>.</p>
<p>The <code>SentinelAlarmActor</code> is used to listen for incoming updates about fire and smoke alarms that have not been reported yet, retrieves respective
evidence (images), and then uses a configurabe set of <code>AlarmMessenger</code> trait objects to report new alarms to the outside world. The primary
choice for production messengers is the <code>SlackAlarmMessenger</code> that pushes notifications to configurable slack channels.</p>
<p>The <code>SentinelSpaService</code> implements a <code>odin_server::SpaService</code> to add a sentinel channel to a single page web application.</p>
<p>The specification of Sentinel data records with respective http access APIs can be found on <a href="http://38.99.249.67:2361/api/">Delphire's Documentation Server</a>. Access of realtime Sentinel data is protected and requires an authentication token from Delphire that can be stored/retrieved in <code>odin_sentinel</code> applications via the [<code>odin_config</code>] crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_goesr"><a class="header" href="#odin_goesr">odin_goesr</a></h1>
<p>This is a user domain crate that supports download and processing of NASA/NOAAs Geostational Operational Environmental Satellite (GOES)
data. At the time of this writing (05/2024) there are two operational satellites: GOES-16 (aka GOES-east) and GOES-18 (aka GOES-west)
observing North and South America. The primary instrument used is the <a href="https://www.ncei.noaa.gov/access/metadata/landing-page/bin/iso?id=gov.noaa.ncdc:C01520">Advanced Baseline Imager (ABI)</a>. The <a href="https://www.goes-r.gov/products/docs/PUG-L2+-vol5.pdf">Product User Guide (PUG) vol. 5</a> contains information about
available data products and formats.</p>
<p>ODIN currently supports the L2 FDCC (Fire/Hotspot Characerization) data product, with future plans for additional data sets such as geo-color
images and lightining detection. Details about FDCC data can be found in the PUG (pg. 472pp).</p>
<p>Data is downloaded from the following AWS S3 buckets:</p>
<ul>
<li><a href="https://noaa-goes16.s3.amazonaws.com/index.html">GOES-16</a></li>
<li><a href="https://noaa-goes18.s3.amazonaws.com/index.html">GOES-18</a></li>
</ul>
<p>which are updated in a 5min interval (data becomes available with +/- 20sec).</p>
<p>The main functions (and general progressions) of this user domain data crate are:</p>
<ol>
<li>timely (minimal latency) data retrieval</li>
<li>translation of external data format (<a href="https://www.unidata.ucar.edu/software/netcdf/">NetCDF</a>) into internal data model</li>
<li>async import/notification with import actor</li>
<li>web (micro) service for browser based visualization (TBD)</li>
<li>archive replay (TBD)</li>
</ol>
<h2 id="modules"><a class="header" href="#modules">modules</a></h2>
<ul>
<li>the main <code>lib</code> module contains the common data model and general (non-application specific) functions to download and translate
respective AWS data sets</li>
<li>the <code>geo</code> module holds functions to compute geodetic coordinates from GOES-R scan angles</li>
<li><code>live_importer</code> does the download schedule computation and realtime data import from AWS S3. It also contains definition of
respective configuration data</li>
<li><code>actor</code> holds the import actor definition that makes the internal data model available in an actor context that provides three
action points (see [odin_action])
<ul>
<li>init (taking the initial data as action input)</li>
<li>update (for each new data set)</li>
<li>on-demand snapshot (requested per message, taking the whole current data as action input)</li>
</ul>
</li>
<li><code>errors</code> has the error type definition for the <code>odin_goesr</code> crate</li>
</ul>
<h2 id="tool-executables"><a class="header" href="#tool-executables">tool executables</a></h2>
<ul>
<li><code>download_goesr_data</code> bin - this is both for testing the download schedule and for retrieving raw data during production</li>
<li><code>read_goesr_hotspots</code> bin - this is a test and production tool to translate single downloaded files into the internal data format</li>
</ul>
<h2 id="example-executables"><a class="header" href="#example-executables">example executables</a></h2>
<ul>
<li><code>goesr_actor</code> example - this shows how to instantiate and connect a [<code>GoesRHotspotImportActor</code>]</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-glossary"><a class="header" href="#4-glossary">4 Glossary</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
