<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ODIN</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="the Open Data Integration Framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="odin.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about.html">About this Document</a></li><li class="chapter-item expanded "><a href="install.html">Installation</a></li><li class="chapter-item expanded "><a href="intro.html">1. Introduction</a></li><li class="chapter-item expanded "><a href="sys_crates.html">2. System Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="odin_build/odin_build.html">odin_build</a></li><li class="chapter-item "><a href="odin_action/odin_action.html">odin_action</a></li><li class="chapter-item "><a href="odin_actor/odin_actor.html">odin_actor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="odin_actor/actor_basics.html">Actor Programming Model</a></li><li class="chapter-item "><a href="odin_actor/actor_impl.html">Basic Design</a></li><li class="chapter-item "><a href="odin_actor/actor_communication.html">Actor Communication</a></li><li class="chapter-item "><a href="odin_actor/examples/examples.html">Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="odin_actor/examples/hello_world.html">hello_world</a></li><li class="chapter-item "><a href="odin_actor/examples/sys_msgs.html">sys_msgs</a></li><li class="chapter-item "><a href="odin_actor/examples/spawn.html">spawn</a></li><li class="chapter-item "><a href="odin_actor/examples/spawn_blocking.html">spawn_blocking</a></li><li class="chapter-item "><a href="odin_actor/examples/exec.html">exec</a></li><li class="chapter-item "><a href="odin_actor/examples/jobs.html">jobs</a></li><li class="chapter-item "><a href="odin_actor/examples/producer_consumer.html">producer_consumer</a></li><li class="chapter-item "><a href="odin_actor/examples/pub_sub.html">pub_sub</a></li><li class="chapter-item "><a href="odin_actor/examples/pin_pong.html">ping_pong</a></li><li class="chapter-item "><a href="odin_actor/examples/query.html">query</a></li><li class="chapter-item "><a href="odin_actor/examples/dyn_actor.html">dyn_actor</a></li><li class="chapter-item "><a href="odin_actor/examples/actions.html">actions</a></li><li class="chapter-item "><a href="odin_actor/examples/dyn_actions.html">dyn_actions</a></li><li class="chapter-item "><a href="odin_actor/examples/retry.html">retry</a></li><li class="chapter-item "><a href="odin_actor/examples/requests.html">requests</a></li><li class="chapter-item "><a href="odin_actor/examples/actor_config.html">actor_config</a></li><li class="chapter-item "><a href="odin_actor/examples/heartbeat.html">heartbeat</a></li></ol></li></ol></li><li class="chapter-item "><a href="odin_server/odin_server.html">odin_server</a></li></ol></li><li class="chapter-item expanded "><a href="app_crates.html">3. Application Domain Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="odin_sentinel/odin_sentinel.html">odin_sentinel</a></li><li class="chapter-item "><a href="odin_goesr/odin_goesr.html">odin_goesr</a></li></ol></li><li class="chapter-item expanded "><a href="glossary.html">Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ODIN</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-this-document"><a class="header" href="#about-this-document">About this Document</a></h1>
<p>this is the developer documentation for the open source ODIN project. Sources are available in the <code>odin_book</code>
directory of the general ODIN repository at <a href="http://github.com/odin-rs">http://github.com/odin-rs</a>, which is distributed under the
<a href="https://www.apache.org/licenses/LICENSE-2.0">Apache v2 license</a>.</p>
<p>The html version can be viewed at <a href="http://github.io/odin-rs">http://github.io/odin-rs</a>.</p>
<p>Sources of this book can be rendered and viewed offline by using <a href="https://rust-lang.github.io/mdBook/">mdbook</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-and-install"><a class="header" href="#build-and-install">Build and Install</a></h1>
<p>This Rust repository contains a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo workspace</a> that consists of several sub-crates (<code>odin_actor</code>, <code>odin_config</code>, ..) that can be built or executed separately.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ol>
<li>
<p><a href="https://git-scm.com/">Git</a> - the version control system that is by now ubiqitous</p>
</li>
<li>
<p><a href="https://www.rust-lang.org/tools/install">Rust toolchain</a> - we recommend to manage the toolchain via <code>rustup</code>
At this point ODIN-RS uses the nightly toolchain. To get, (locally) install <code>rustup</code> and switch to the nightly toolchain execute:</p>
<pre><code class="language-shell">$&gt; curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
...
$&gt; rustup default nightly
</code></pre>
<p>Periodic updates of the toolchain can be done by executing <code>rustup update</code></p>
<p>To install the <a href="https://rust-lang.github.io/mdBook/"><code>mdbook</code></a> tool to compile and serve online documentation
please run <code>cargo install mdbook</code></p>
</li>
<li>
<p><a href="https://gdal.org/">GDAL</a> - this platform specific native library for handling geospatial data is required by the
<code>odin_gdal</code> crate and should be installed through respective package managers for your operating system</p>
<ul>
<li>Linux: gdal packages are available for all major Linux distributions through their native package managers</li>
<li>macOS: <a href="https://brew.sh/">homebrew</a>: <code>brew install gdal</code></li>
<li>windows: <a href="https://learn.microsoft.com/en-us/vcpkg/get_started/overview">vcpkg</a></li>
</ul>
</li>
</ol>
<h3 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h3>
<p>Since many ODIN applications require configuration or other data files at runtime it is recommended to keep the repository
and such files under a single root directory. To conform with the <code>odin_build</code> crate we recommend the following structure:</p>
<pre><code>.
└── ❬odin-root-dir❭/                    created before cloning odin-rs
    ├── configs/...                       read-only data deserialized into config structs
    ├── assets/...                        read-only binary data served by ODIN app
    ├── data/...                          persistent runtime data for ODIN apps
    ├── cache/...                         transient runtime data for ODIN apps
    │
    └── odin-rs/...                     ⬅︎ directory into which ODIN source repository is cloned
</code></pre>
<p>The name of the ❬odin-root-dir❭ can be chosen at will. You can have several root dirs with different odin versions/branches and/or resource files. An installation as outlined above does not require any environment variables to set.</p>
<p>Resource directories (configs/, assets/ and data/) can be populated upon demand later-on - please see the [odin_build] documentation for further details.</p>
<p>On a Unix/macOS system this amounts to a sequence of commands like:</p>
<pre><code class="language-shell">$&gt; mkdir my-odin
$&gt; cd my-odin
$&gt; mkdir configs assets data cache
$&gt; git clone http://github.com/nasa-odin/odin-rs  # or other odin-rs repository URL
...
$&gt; cd odin-rs
</code></pre>
<h3 id="build-instructions"><a class="header" href="#build-instructions">Build instructions</a></h3>
<p>Building and running ODIN-RS executables is normally done through the command line <a href="https://doc.rust-lang.org/cargo/index.html"><code>cargo</code></a> tool which is installed by <code>rustup</code> as mentioned above. While ODIN-RS can be built directly from the directory where this repository was cloned to we recommend to switch to the respective crate you are interested in, e.g.</p>
<pre><code class="language-shell">$&gt; cd odin_actor
$&gt; cargo run --example hello_world
   Compiling proc-macro2 v1.0.79
   ...
     Running `.../odin-rs/target/debug/examples/hello_world`
hello world!
</code></pre>
<p>For IDEs we recommend <a href="https://code.visualstudio.com/docs/languages/rust">Visual Studio Code with the Rust Analyzer extension</a> - just choose "File-&gt;Open Folder" with the directory this repository was cloned to and you should be all set.</p>
<p>To build/browse this documentation you have to install the Rust <a href="https://rust-lang.github.io/mdBook/"><code>mdbook</code></a> tool:</p>
<pre><code class="language-shell">$&gt; cargo install mdbook
...
$&gt; cd odin_book
$&gt; mdbook serve
2024-07-18 10:07:57 [INFO] (mdbook::book): Book building has started
2024-07-18 10:07:57 [INFO] (mdbook::book): Running the html backend
2024-07-18 10:07:57 [INFO] (mdbook::cmd::serve): Serving on: http://localhost:3000
...
</code></pre>
<p>Once the mdbook server is running you can view the odin_book contents in any browser at http://localhost:3000</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>ODIN is a software framework to efficiently create servers that support disaster management.</p>
<img class="mono right" src="../img/info-fragmentation.svg" width="40%"/>
<p>More specifically it is a framework to build servers that import and process an open number of external data sources for information such as weather, ground-/aerial- and space-based sensors, threat assessment, simulation, vehicle/crew tracking and many more. The over-arching goal is to improve situational awareness of stakeholders by making more - and more timely - information available in stakeholder-specific applications. The main challenge for this is not the availability of data, it is how this data can be integrated in extensible and customizable applications.</p>
<p>We want to mitigate the <strong>information fragmentation- and compartmentalization problem</strong>. No more hopping between dozens of browser tabs. No more manual refreshes to stay up-to-date. No more printouts to communicate. No more take-it-or-leave-it systems that can't be extended.</p>
<p>ODINs goal is <em>not</em> to create yet another website that is supposed to replace all the ones that already exist. We want to enable stakeholder organizations to assemble <em>their</em> server applictions showing the information <em>they</em> need, with the capability to run those servers/applications on <em>their</em> machines (even out in the field if need be). We also want to do this in a way that makes it easy to integrate new data sources and functions as they become available from government, research organizations and commercial vendors. We want ODIN to be extensible, scalable, portable - and last not least - accessible.</p>
<p>To that end ODIN is open sourced under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache v2 license</a>. It is a library you can use and extend in your projects.</p>
<h2 id="stakeholders"><a class="header" href="#stakeholders">Stakeholders</a></h2>
<img class="mono left" src="../img/stakeholders.svg" width="55%"/>
<p>Our vision for ODIN goes beyond a single stakeholder. We want it to be an open (freely available) platform for both users and developers. The ODIN maintainers are just one part of the puzzle, developing and maintaining the core framework other developers can build on. We only see our role in creating generic components that implement a consistent, extensible and scalable architecture.</p>
<p>User stakeholders are more than just responder organizations (of which there are many). We also envision local communities who want to improve their level of preparedness / disaster planning. Another example would be utility providers monitoring critical infrastructure. The common goal for such user stakeholders is to enhance their situational awareness but what information that entails depends on the specific incident type, stakeholder and location.</p>
<p>What holds for most user stakeholder organizations is that they lack the resources to develop respective systems from scratch. The stakeholders who do have development capacity often find themselves reinventing the wheel. The stakeholders who subscribe to commercial services have no way to tailor or extend such services.</p>
<p>There is no single organization that could develop all service components on its own. Commercial vendors come up with new sensors. Research organizations develop new forecast models and simulators. What holds for all such provider stakeholders is that they want to focus on their specific expertise. They don't want to duplicate existing functions just to make their products available. If they do so it just increases the information fragmentation problem we started with.</p>
<p>ODIN aspires to become the common ground on which stakeholders can meet - free, open and extensible for all.</p>
<h2 id="underlying-sw-architecturedesign"><a class="header" href="#underlying-sw-architecturedesign">Underlying SW Architecture/Design</a></h2>
<img class="mono right" src="../img/actors-mono.svg" width="35%"/>
<p>To be that common basis ODIN needs a strong architectural foundation. Since ODINs main task is to collect and then process data from various independent external sources we need good support for concurrent computation - one of the most challenging topics for software development. ODIN meets this challenge by using the <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Programming Model</a>: asynchronously executing objects which only communicate through messages and don't share internal state (see <a href="odin_actor/odin_actor.html">odin_actor</a> and <a href="odin_actor/actor_basics.html">The Actor Programming Model</a> for details).</p>
<p>ODIN also has to work with existing software. There is a large collection of existing work we want to build on, such as fire-behavior and micro grid wind simulators (e.g. <a href="https://weather.firelab.org/windninja/">WindNinja</a>) and general geospatial data processing libraries (e.g. <a href="https://gdal.org/">GDAL</a>). Given the binary nature of many of the underlying data formats, the need to efficiently use 3rd-party native libraries, the challenges of concurrent programming and the portability we strive for we chose <a href="https://www.rust-lang.org/">Rust</a> as the implementation platform as it gives us</p>
<ul>
<li>language intrinsic memory- and thread- safety</li>
<li>a well defined <a href="https://en.wikipedia.org/wiki/Application_binary_interface">Application Binary Interface</a></li>
<li>a comprehensive cross-platform standard library</li>
<li>a huge external <a href="https://crates.io/">eco-system</a></li>
<li>good asynchronous programming support, both in the language and its libraries</li>
<li>powerful abstraction features for large scale program design</li>
<li>a mature, consistent tool chain (especially including dependency management)</li>
<li>high efficiency / low system overhead (one of Rusts design goals is "zero cost abstraction")</li>
</ul>
<p>What do we want to build on that basis?</p>
<h2 id="odin-application-types"><a class="header" href="#odin-application-types">ODIN Application Types</a></h2>
<p>While ODIN contains all sort of command line tools, the primary targets are two types of servers:</p>
<ul>
<li>user servers - providing data visualization for end users</li>
<li>edge servers - factoring out network-, compute- and data volume-intense tasks to dedicated machinery</li>
</ul>
<p>Both are built from the same ODIN components and follow the same architectural design outlined above.</p>
<h3 id="user-servers"><a class="header" href="#user-servers">User Servers</a></h3>
<p>ODIN user servers are not supposed to handle millions of requests from large numbers of simultaneous but isolated users. The servers we mainly target support medium size workgroups of stakeholder users (&lt;1000) with the need for:</p>
<ul>
<li>automatic data update (also for low latency tracking data)</li>
<li>collaboration (synchronized views)</li>
</ul>
<p>The main application model for user servers is a <a href="https://en.wikipedia.org/wiki/Single-page_application">Single Page Application</a>. The main user interface is a web browser - ODIN does not require end user installation and can be used on existing machinery.</p>
<img class="mono left" src="../img/odin-spa-mono.svg" width="45%"/>
<p>A Single Page Application (SPA) mainly uses two types of actors: importers and a SPAServer. An Importer is a dedicated component to handle a single external data source, including data retrieval schedule and translation into ODIN internal format (if required). Importers are completely independent of each other which makes it simple to add new ones. Their results are sent via messages to a SPA-Server actor that distributes the information to connected users.</p>
<p>The SPA-Server actor utilizes MicroService objects that are managing static and dynamic content which is shown as separate layers on the served web page. Static content mostly consists of HTML and associated Javascript modules. It can be initialized from files or compiled into stand-alone executables and is served via http(s) protocol.</p>
<p>Stand alone ODIN SPA servers do not require any additional files/installation other than the executable itself (see <a href="odin_build/odin_build.html">odin_build</a> for details). They can be thought of as traditional desktop applications that just use a browser as the user interface.</p>
<p>To ensure realtime update (down to 1Hz) of low latency data such as tracked objects ODIN utilizes <a href="https://en.wikipedia.org/wiki/WebSocket">WebSockets</a> that are managed by the MicroService objects, and processed in the browser by ODINs Javascript modules (assets).</p>
<p>For geospatial display in the browser ODIN uses the open source <a href="https://cesium.com/platform/cesiumjs/">CesiumJS</a> library, which is built on top of <a href="https://en.wikipedia.org/wiki/WebGL">WebGL</a> and hence supports hardware accelerated 3D graphics to display a virtual globe.</p>
<p>ODINs user interface components such as (movable) windows, lists and buttons are implemented with ODINs own Javascript library that resembles a traditional desktop and is highly (user-) configurable.</p>
<h3 id="edge-servers"><a class="header" href="#edge-servers">Edge Servers</a></h3>
<p>ODIN edge servers are the means to make ODIN applications scalable - they provide condensed/consolidated input data for user servers by factoring out high computational workloads and/or large input data volumes into dedicated machines with high speed network access. Edge servers are primarily used to reduce downstream processing and data volume.</p>
<img class="mono right" src="../img/odin-edge-mono.svg" width="45%"/>
<p>Assume for instance micro-grid (location/terrain- aware) wind forecast for a given incident area, such as provided by <a href="https://weather.firelab.org/windninja/">WindNinja</a>. This not only requires high speed machinery to execute the simulation but also needs significant bandwidth/connectivity to periodically obtain the required input data such as weather forecasts and station reports, high resolution digital elevation models, vegetation/fuel models and more. The user-facing results of the simulation can be compiled into relatively simple text (CSV) files containing a wind vector grid in the area of interest.</p>
<p>As a general rule we want to be able to run functions where the data is most easily accessible. For information that is obtained from sensors in the field (such as local tracking data) that can be a local incident command server. For functions that use large amounts of input such as NOAA weather forecasts this can be a high speed data center. For functions that are computationally expensive this should be a super computer.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>To get an idea of what ODIN servers might look like on end user machines we refer to two of our TFRSAC talks:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=b9DfMBYCe-s&amp;t=4950s">spring 2023</a></li>
<li><a href="https://www.youtube.com/watch?v=gCBXOaybDLA">fall 2022</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-crates"><a class="header" href="#system-crates">System Crates</a></h1>
<p>As the name implies ODIN <em>system crates</em> provide functionality that is not directly associated to a specific application domain such as weather or even the general topic of disaster management. Most of them can be used for non-ODIN applications.</p>
<p>ODIN system crates can be divided into 3 categories:</p>
<h2 id="odin-development"><a class="header" href="#odin-development">ODIN development</a></h2>
<ul>
<li><a href="odin_build/odin_build.html">odin_build</a> - this crate is a build- and runtime dependency for other ODIN crates. It
provides the mechanism to build stand-alone applications that do not rely on separate resource files</li>
<li><a href="odin_macro/odin_macro.html">odin_macro</a> - this is collection of macros that implement domain specific languages
used especially by <code>odin_actor</code></li>
</ul>
<h2 id="cross-cutting-functions"><a class="header" href="#cross-cutting-functions">cross-cutting functions</a></h2>
<ul>
<li><a href="odin_common/odin_common.html">odin_common</a> - this is primarily a collection of cross-cutting functions that extend
the Rust standard libraries and provide some basic capabilities such as admin notification</li>
<li><a href="odin_gdal/odin_gdal.html">odin_gdal</a> - a crate that wraps and extends the <a href="https://gdal.org">GDAL</a> library for geo-spatial
data sets and images</li>
</ul>
<h2 id="architectural-crates"><a class="header" href="#architectural-crates">architectural crates</a></h2>
<ul>
<li><a href="odin_actor/odin_actor.html">odin_actor</a> - this crate implements a full actor system and is the architectural
basis for most ODIN app crates</li>
<li><a href="odin_action/odin_action.html">odin_action</a> - a crate that provides generic callbacks (used primarily to make
actors inter-operable)</li>
<li><a href="odin_job/odin_job.html">odin_job</a> - general system-global scheduling</li>
<li><a href="odin_server/odin_server.html">odin_server</a> - this crate provides the building blocks to construct web server actors</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_build"><a class="header" href="#odin_build">odin_build</a></h1>
<p><code>odin_build</code> is a library crate that is used in a dual role both for utility functions called by ODIN crate specific
<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripts</a> and at application runtime to locate resources and global directories.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>The primary use of ODIN is to create servers - either interactive web-servers or edge-servers used by other applications. To that end ODIN servers support four general categories of data:</p>
<ol>
<li>configs - essential runtime invariant configuration data (e.g. URIs and user credentials for external servers)</li>
<li>assets - essential runtime invariant data that is served/used by ODIN (e.g. CSS and Javascript modules for web servers)</li>
<li>data - global persistent data for ODIN applications that can change independently of the ODIN application using them</li>
<li>cache - global transient data for ODIN applications (e.g. cached responses from proxied servers)</li>
</ol>
<p>Configs and assets are essential <strong>resources</strong>, i.e. applications can rely on their existence (but not their values). For <code>data</code> and <code>cache</code> we only guarantee that respective directories exist at runtime - the use of those directories is up to individual applications.</p>
<p>Common to all categories is that such data can change independently of the ODIN Rust sources using them and hence do need a consistent, well defined lookup mechanism used throughout all ODIN applications. That mechanism is implemented in <code>odin_build</code>, mostly through four functions:</p>
<ul>
<li><code>❬crate❭::load_config&lt;C&gt; (file_name: &amp;str)-&gt;Result&lt;C&gt;</code> (<code>C</code> being the type of the requested, deserializable config struct)</li>
<li><code>❬crate❭::load_asset (file_name: &amp;str)-&gt;Result&lt;Bytes&gt;</code></li>
<li><code>odin_build::data_dir()-&gt;&amp;'static PathBuf</code></li>
<li><code>odin_build::cache_dir()-&gt;&amp;'static PathBuf</code></li>
</ul>
<p>The reason why the first two functions reside in the crates defining respective resources is that we also support stand-alone ODIN applications that can be distributed as single executable files, without the need to install (potentially sensitive) resource files (e.g. containing user authentication for 3rd party servers). This seems to be incompatible with that resource values can be changed independently of ODIN Rust sources.</p>
<p>To reconcile the two requirements we support a general build mode for ODIN applications that takes (at build-time) resource files and generates statically linked Rust sources from them. Generating source fragments for such <strong>embedded resources</strong> is done by build scripts utilizing functions provided by <code>odin_build</code>. The data flow is as follows:</p>
<pre><code>      ┌────────────────┐                                                            
      │crate odin_build│                                                            
      └──────┬─────────┘                                                            
             │          ┌─────────────────────┐                                     
             │          │ crate my_crate      │        [cargo]                            
             │          │                     │      $OUT_DIR (../target/❬mode❭/build/A-../out/)                                  
             │          │   Cargo.toml (0)    │    ┌─────────────┐                  
             ╰──────────┼─► build.rs  ───(1)──┼───►│ config_data │                  
                        │   src/              │    └┬───▲──▲─────┘                  
                        │  ╭─ lib.rs ◄───(2)──┼─────╯   ╎  ╎
                        │  │  ...             │         ╎  ╎
                        │ (3) bin/            │         ╎  ╎
                        │  ╰─►  my_app.rs     │         ╎  ╎          [user]
                        │     ...             │         ╎  ╎        $ODIN_ROOT/         
                        │   configs/ ╶╶╶╶╶╶╶╶╶┼╶╶╶╶╶╶╶╶╶╯  ╰╶╶╶╶╶╶     configs/          
                        │     my_config.ron   │   internal or external    my_crate/             
                        └─────────────────────┘         resource             my_config.ron

</code></pre>
<p>This involves several steps:</p>
<h3 id="0-declaration-of-embeddable-resources-in-cargotoml-manifest-of-owning-crates"><a class="header" href="#0-declaration-of-embeddable-resources-in-cargotoml-manifest-of-owning-crates">(0) declaration of embeddable resources in Cargo.toml manifest of owning crates</a></h3>
<p>The first step is to specify package meta data for embeddable resource files in the crates owning them (henceforth called <strong>resource crate</strong>):</p>
<pre><code class="language-toml">[[bin]]
name = "my_app"

[package.metadata.odin_configs]
my_config = { file="my_config.ron" }
...
[package.metadata.odin_assets]
my_asset = { file="my_asset.js", bins=["my_app"] }

[features]
embedded_resources = []
...
</code></pre>
<p>The <code>embedded_resource</code> feature should be transitive - if the resource crate in turn depends on other ODIN resource crates we have to pass-down the feature like so: <code>embedded_resources = ["❬other-odin-crate❭/embedded_resources" …]</code></p>
<h3 id="1-creation-of-embedded-resource-data"><a class="header" href="#1-creation-of-embedded-resource-data">(1) creation of embedded resource data</a></h3>
<p>This step uses a build script of the resource crate to generate embedded resource code by calling functions from <code>odin_built</code>, showing its role as a build-time library crate:</p>
<pre><code class="language-rs"> use odin_build;

 fn main () {
     odin_build::init_build();
     odin_build::create_config_data().expect("failed to generate config_data");
     odin_build::create_asset_data().expect("failed to generate asset_data");
 }
</code></pre>
<p>Note that using embedded resources requires the <code>embedded_resources</code> <a href="https://doc.rust-lang.org/cargo/reference/features.html">feature</a> when building resource crates since it involves conditional compilation (more specifically feature-gated <code>import!(❬embedded-resource-fragment❭)</code> calls).</p>
<p>ODIN stores all embedded resource data in compressed format. Depending on resource file type data might be minified before compression.</p>
<h3 id="2-declaration-of-resource-accessor-functions-in-resource-crates"><a class="header" href="#2-declaration-of-resource-accessor-functions-in-resource-crates">(2) declaration of resource accessor functions in resource crates</a></h3>
<p>At application runtime we use two macros from <code>odin_build</code> that expand into crate-specific public <code>load_config(…)</code> and <code>load_asset(…)</code> functions mentioned above.</p>
<pre><code class="language-rs">use odin_build::{define_load_config,define_load_asset};

define_load_config!{}
define_load_asset!{}
...
</code></pre>
<p>If the application was built with the <code>embedded_resources</code> feature the expanded <code>load_config(…)</code> and <code>load_asset(…)</code> functions conditionally import the resource code fragments.</p>
<h3 id="3-use-of-resources"><a class="header" href="#3-use-of-resources">(3) use of resources</a></h3>
<p>Using resource values at runtime is done through calling the expanded <code>load_config(…)</code> and <code>load_asset(…)</code> functions, which only require abstract resource filenames (not their location). The application source code is fully independent of the build mode:</p>
<pre><code class="language-rs">fn main() {
    odin_build::set_bin_context();
    ...
    let config: MyConfig = load_config("my_config.ron")?;
    ...
    let asset: &amp;Vec&lt;u8&gt; = load_asset("my_asset.js)?;
}
</code></pre>
<h2 id="resource-lookup"><a class="header" href="#resource-lookup">Resource Lookup</a></h2>
<p>We use the same algorithm for each individual resource file lookup during build-time and application run-time. This algorithm is implemented in <code>odin_build::find_resource_file(…)</code> and based on two main directory types of ODIN:</p>
<ul>
<li><strong>root directories</strong></li>
<li><strong>workspace directories</strong></li>
</ul>
<h3 id="odin-root-dir"><a class="header" href="#odin-root-dir">ODIN Root Dir</a></h3>
<p>A <strong>root-dir</strong> is a directory that contains resource data that is kept outside of the source repository. ODIN applications are not supposed to rely on anything outside their root-dir but the user can control which root-dir to use (there can be several of them, e.g. for development and production)</p>
<p>We detect the root-dir to use in the following order:</p>
<ol>
<li>whatever the optional environment variable <code>ODIN_ROOT</code> is set to</li>
<li>the parent of a workspace dir <strong>iff</strong> the current dir is (within) an ODIN workspace and this parent contains any of <code>cache/</code>,
<code>data/</code>, <code>configs/</code> or <code>assets/</code> sub-dirs. This is to support a self-contained directory structure during development, not
requiring any environment variables</li>
<li>a <code>$HOME/.odin/</code> otherwise - this is the normal production mode</li>
</ol>
<p>An ODIN <strong>root-dir</strong> can optionally contain other sub-directories such as the ODIN <strong>workspace-dir</strong> mentioned below.</p>
<pre><code>.
└── ❬odin-root-dir❭/
    ├── configs/                        read-only data deserialized into config structs
    │   ├── ❬resource-crate❭/
    │   │   ├── ❬resource-file❭
    │   │   └── ...
    │   └── ❬bin-crate❭/
    │       └── ❬resource-crate❭/
    │           ├── ❬resource-file❭     bin specific override
    │           └── ...
    ├── assets/                         read-only binary data served by ODIN app
    │   ├── ❬resource-crate❭/...
    │   └── ❬bin-crate❭/...
    │
    ├── data/                           persistent runtime data for ODIN apps
    │   └── ...
    │
    ├── cache/                          transient runtime data for ODIN apps
    │   └── ...
    │
    └── ... (e.g. odin-rs/)             optional dirs (ODIN workspace-dir etc.)
</code></pre>
<h3 id="odin-workspace-dir"><a class="header" href="#odin-workspace-dir">ODIN Workspace Dir</a></h3>
<p>The <strong>workspace-dir</strong> is the top directory of an ODIN source repository, i.e. the directory into which the <code>odin-rs</code> Github repository was cloned. While the primary content of a <strong>workspace-dir</strong> are the ODIN crate sources, such crates <em>can</em> contain
configs and assets in case those should be kept within the source repository. This is typically the case for crates that serve/communicate with Javascript module assets - here we want to make sure asset and related ODIN Rust code are kept together.</p>
<p>The <strong>workspace-dir</strong> is the topmost dir that holds a Cargo.toml, starting from the current dir.</p>
<p>A <strong>workspace-dir</strong> follows the normal cargo convention but adds optional <code>configs/</code> and <code>assets/</code> sub-directories to respective workspace crates:</p>
<pre><code>.
└── ❬odin-workspace-dir❭/
    ├── Cargo.toml                     ODIN workspace definition    
    ├── ❬crate-dir❭/
    │   ├── Cargo.toml                 including odin_configs and odin_assets metadata
    │   ├── build.rs                   calling odin_build functions
    │   ├── src/...                    normal Cargo dir structure
    │   │
    │   ├── configs/                   (optional) in-repo config resources for this crate
    │   │   ├── ❬resource-file❭
    │   │   └── ...
    │   └── assets/                    (optional) in-repo asset resources for this crate
    │       ├── ❬resource-file❭
    │       └── ...
    ├── ...                            other ODIN crates
    └── target/...                     build artifacts   
</code></pre>
<p>With those directory types we can now define the resource file lookup algorithm:</p>
<h3 id="file-lookup-algorithm"><a class="header" href="#file-lookup-algorithm">File Lookup Algorithm</a></h3>
<p>For each given tuple</p>
<ul>
<li>root-dir (ODIN_HOME | workspace-parent | ~/.odin)</li>
<li>(optional) workspace-dir</li>
<li>resource type ("configs" or "assets"),</li>
<li>resource filename,</li>
<li>resource crate and</li>
<li>(optional) bin name + crate</li>
</ul>
<p>check in the following order:</p>
<ol>
<li>root-dir / resource-type / bin-crate / bin-name / resource-crate / filename</li>
<li>root-dir / resource-type / resource-crate / filename</li>
<li>workspace-dir / resource-type / bin-crate / bin-name / resource-crate / filename</li>
<li>workspace-dir / resource-type / resource-crate / filename</li>
</ol>
<p>This is implemented in the <code>odin_build::find_resource_file(…)</code> function which returns an <code>Option&lt;PathBuf&gt;</code>.</p>
<h3 id="runtime-resource-lookup-algorithm"><a class="header" href="#runtime-resource-lookup-algorithm">Runtime Resource Lookup Algorithm</a></h3>
<p>At application runtime we optionally extend the above file system lookup mechanism by checking for an embedded resource within the resource-crate <strong>iff</strong> no file was found with the above algorithm.</p>
<p>By setting a runtime environment variable <code>ODIN_EMBEDDED_ONLY=true</code> we can force the lookup to only consider embedded resources (i.e. to ignore resource files in the file system).</p>
<p>This lookup is performed for each resource separately, i.e. it is not just possible but even usual to have resources to reside in different locations (root dir and workspace dir). Typically only configs with user settings or credentials are kept outside the repository whereas assets are kept within. The main exception would be development/test environments.</p>
<h2 id="odin-environment-variables"><a class="header" href="#odin-environment-variables">ODIN Environment Variables</a></h2>
<p>At runtime, ODIN applications use the following optional environment variables:</p>
<ul>
<li><code>ODIN_HOME</code></li>
<li><code>ODIN_EMBEDDED_ONLY</code></li>
</ul>
<p>At build-time, ODIN uses the following environment variables to provide build script input</p>
<ul>
<li><code>ODIN_BIN_CRATE</code> - set manually or by ODIN build tool</li>
<li><code>ODIN_BIN_NAME</code> - set manually or by ODIN build tool</li>
<li><code>ODIN_EMBED_RESOURCES</code> - set manually or by ODIN build tool</li>
<li><code>OUT_DIR</code> - automatically set by cargo</li>
<li><code>CARGO_PKG_NAME</code> - automatically set by cargo</li>
<li><code>CARGO_BIN_NAME</code> - automatically set by cargo for bin target</li>
</ul>
<h2 id="odin-build-tools"><a class="header" href="#odin-build-tools">ODIN build tools</a></h2>
<p>To further simplify building applications with embedded resources <code>odin_build</code> includes a tool that automates setting required environment variables, calling cargo and reporting embedded files:</p>
<pre><code>bob [--embed] [--root ❬dir❭] [❬cargo-opts❭...] ❬bin-name❭
  --embed      : build binary with embedded resources
  --root ❬dir❭ : set ODIN root dir to embed resources from
</code></pre>
<p>Using this tool is optional. ODIN applications can be built/run through normal cargo invocation but in this case resources are not embedded without manually setting the above <code>ODIN_..</code> build-time environment variables and the <code>embedded_resources</code> feature.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_action"><a class="header" href="#odin_action">odin_action</a></h1>
<p>The <code>odin_action</code> crate provides several variants of <strong>action</strong> types together with macros to define and instantiate ad
hoc actions. The generic <strong>action</strong> construct represents application specific objects that encapsulate async
computations, to be executed by an <em>action owner</em> that can invoke such computations with its own data (e.g. sending
messages in actor systems that are built from its data).</p>
<p>The primary purpose of actions is to build re-usable action owners that do not have to be aware of in which
application context they are used. All the owner has to know is when to execute an action and what of its own data
it should provide as an argument.</p>
<p>In a synchronous world this is often described as a "callback".</p>
<p>The basis for this are "Action" traits with a single <code>async fn execute(&amp;self,data..)-&gt;Result&lt;()&gt;</code> method. Instances of
these traits are normally created where we assemble an application (e.g. in <code>main()</code>), i.e. where we know all the
relevant interaction types. They are then passed either as generic type constructor arguments or later-on (at runtime)
as trait objects to their owners, to be invoked either on-demand or when the owner state changes.</p>
<p>Technically, actions represent a special case of async closures in which capture is done by either <code>Copy</code>
or <code>Clone</code>. Reference capture is not useful here since actions are executed within another task, without any
lifetime relationship to the context in which the actions were created.</p>
<p>We support the following variants:</p>
<ul>
<li>[<code>DataAction&lt;T&gt;</code>] trait and ['data_action`] macro</li>
<li>[<code>DataRefAction&lt;T&gt;</code>] trait and ['dataref_action`] macro</li>
<li>[<code>BiDataAction&lt;T,A&gt;</code>] trait and [<code>bi_data_action</code>] macro</li>
<li>[<code>BiDataRefAction&lt;T,A&gt;</code>] trait and [<code>bi_dataref_action</code>] macro</li>
<li>[<code>DynDataAction&lt;T&gt;</code>] type and ['dyn_data_action`] macro</li>
<li>[<code>DynDataRefAction&lt;T&gt;</code>] type and ['dyn_dataref_action`] macro</li>
</ul>
<p>The difference between <code>..DataAction</code> and <code>..DataRefAction</code> is how the owner data is passed into the trait's
<code>execute(..)</code> function: as a moved value (<code>execute(&amp;self,data:T)</code>) or as a reference (<code>execute(&amp;self,data:&amp;T)</code>).</p>
<p>The <code>Bi..Action&lt;T,B&gt;</code> traits have <code>execute(..)</code> functions that take two arguments (of potentially different types). This is
helpful in a context where the action body requires both owner state (<code>T</code>) and information that was passed to the
owner (<code>B</code>) in the request that triggers the action execution and can avoid the runtime overhead of async action trait
objects (requiring <code>Pin&lt;Box&lt;dyn Future ..&gt;&gt;</code> execute return values). The limitation of bi-actions is that both
action owner and requester have to know the bi_data type (<code>B</code>), which therefore tends to be unspecific (e.g. <code>String</code>).
This in turn makes bi-actions more susceptible to mis-interpretation and therefore the action owner should only use
<code>B</code> as a pass-through argument and not generating it (which would require the owner knows what potential requesters
expect semantically).</p>
<p><code>Dyn..Action</code> types (which represent trait objects) are used in two different contexts:</p>
<ul>
<li>to execute actions that were received as function arguments (e.g. through async messages)</li>
<li>to store such actions in homogenous <code>Dyn..ActionList</code> containers for later execution</li>
</ul>
<p>The <code>Dyn..ActionList</code> containers use an additional <code>ignore_err: bool</code> argument in their <code>execute(..)</code> methods
that specifies if the execution should shortcut upon encountering error results when executing its stored actions
or if return values of stored actions should be ignored.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyActor { ...
    data: MyData, 
    actions: DynDataActionList&lt;MyData&gt;
}
...
impl MyActor {
    async fn exec (&amp;self, da: DynDataAction&lt;MyData&gt;) { 
        da.execute(&amp;self.data).await;
    }

    fn store (&amp;mut self, da: DynDataAction&lt;MyData&gt; ) { 
        .. self actions.push( da) ..
    }
    ... self.actions.execute(&amp;self.data, ignore_err).await ...
}
<span class="boring">}</span></code></pre></pre>
<p>Note that <code>Dyn..Action</code> instances do have runtime overhead (allocation) per <code>execute(..)</code> call.</p>
<p>Since actions are typically one-of-a-kind types we provide macros for all the above variants that both define the type
and return an instance of this type. Those macros all follow the same pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//--- system construction site:
let v1: String = ...
let v2: u64 = ...
let action = data_action!( v1.clone() : String, v2 =&gt; |data: Foo| {
   println!("action executed with arg {:?} and captures v1={}, v2={}", data, v1, v2);
   Ok(())
});
let actor = MyActor::new(..action..);
...
//--- generic MyActor implementation:
struct MyActor&lt;A&gt; where A: DataAction&lt;Foo&gt; { ... action: A ... }
impl&lt;A&gt; MyActor&lt;A&gt; where A: DataAction&lt;Foo&gt; {
  ... let data = Foo{..}
  ... self.action.execute(data).await ...
}
<span class="boring">}</span></code></pre></pre>
<p>the example above expands into a block with three different parts: capture struct definition, action trait impl and capture struct instantiation</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    struct SomeDataAction { v1: String, v2: u64 }

    impl DataAction&lt;Foo&gt; for SomeDataAction {
         async fn execute (&amp;self, data: Foo)-&gt;std::result::Result&lt;(),OdinActionError&gt; {
             let v1 = &amp;self.v1; let v2 = &amp;self.v2;
             println!(...);
             Ok(())
         }
    }

    SomeDataAction{ v1: v1.clone(), v2 }
}
<span class="boring">}</span></code></pre></pre>
<p>The action bodies are expressions that have to return a <code>Result&lt;(),OdinActionError&gt;</code> so that we can coerce errors in crates using
<code>odin_action</code>. This means that we can use the <code>?</code> operator to shortcut within action bodies, but we have to map respective results
by means of our <code>map_action_err()</code> function and make sure to use <code>action_ok()</code> instead of explicit <code>Ok(())</code> (to tell the compiler
what <code>Result&lt;T,E&gt;</code> it refers to):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute_some_result(...)-&gt;Result&lt;(),SomeError&gt; {...}
...
data_action!( ... =&gt; |data: MyData| {
    ...
    map_action_err( compute_some_result(...) )?
    ...
    action_ok()
})
<span class="boring">}</span></code></pre></pre>
<p>For actions that end in a result no mapping is required (<code>map_action_err(..)</code> is automatically added by the macro expansion):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>data_action!( ... =&gt; |data: MyData| {
    ...
    compute_some_result(...)
})
<span class="boring">}</span></code></pre></pre>
<p>[<code>OdinActionError</code>] instances can be created from anything that implements [<code>ToString</code>]`</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_actor"><a class="header" href="#odin_actor">odin_actor</a></h1>
<p>The <code>odin_actor</code> crate provides an implementation for a typed <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a>
that serves as the common basis for ODIN applications.</p>
<p><em>Actors</em> are objects that execute concurrently and only communicate through asynchronous <em>Messages</em>. Actors do not share their internal <em>State</em> and are only represented to the outside by <em>ActorHandles</em>. The only operation supported by ActorHandles is to send messages to the actor, which are then queued in an (actor internal) <em>Mailbox</em> and processed by the actor in the order in which they were received. In reaction to received messages actors can send messages or mutate their internal state:</p>
<pre><code>         ╭──────╮
   ─────▶︎│Handle│─────x:X──╮ Message
       ┌─┴──────┴──────────│───┐
       │ Actor   State   ┌─▼─┐ │
       │          ▲      ├─:─┤ MailBox
       │          │      └───┘ │
       │          ▼        │   │
       │   receive(m) ◀︎────╯   │
       │     match m           │
       │       X =&gt; process_x  │
       │    ...          ───────────▶︎ send messages to other actors
       └───────────────────────┘ 
</code></pre>
<p>From a Rust perspective this is a library that implements actors as async tasks that process input received through
actor-owned channels and encapsulate actor specific state that is not visible to the outside. It is an architectural
abstraction layer on top of async runtimes (such as <a href="https://tokio.rs/">tokio</a>).</p>
<p>In <code>odin_actor</code> we map the message interface of an actor to an <code>enum</code> containing variants for all message types
understood by this actor (variants can be anything that satisfies Rust's <code>Send</code> trait). The actor state is a user
defined <code>struct</code> containint the data that is owned by this actor. Actor behavior defined as a <code>trait</code> impl that
consists of a single <code>receive</code> function that matches the variants of the actor message enum to user defined expressions.</p>
<p>Please refer to the respective chapter in the <code>odin_book</code> for more details.</p>
<p>The <code>odin_actor</code> crate mostly provides a set of macros that implement a DSL for defining and instantiating these
actor components, namely</p>
<ul>
<li>[<code>define_actor_msg_set</code>] to define an enum for all messages understood by an actor</li>
<li>[<code>impl_actor</code>] to define the actor as a 3-tuple of actor state, actor message set and a <code>receive</code> function that provides
the (possibly state dependent) behavior for each input message (such as sending messages to other actors)</li>
<li>[<code>spawn_actor</code>] to instantiate actors and start their message receiver tasks</li>
</ul>
<p>Here is the "hello world" example of <code>odin_actor</code>, consisting of a single Greeter actor:</p>
<pre><pre class="playground"><code class="language-rust">use tokio;
use odin_actor::prelude::*;

// define actor message set ①
#[derive(Debug)] pub struct Greet(&amp;'static str);
define_actor_msg_set! { pub GreeterMsg = Greet }

// define actor state ②
pub struct Greeter { name: &amp;'static str }

// define the actor tuple (incl. behavior) ③
impl_actor! { match msg for Actor&lt;Greeter,GreeterMsg&gt; as
    Greet =&gt; term! { println!("{} sends greetings to {}", self.name, msg.0); }
}

// instantiate and run the actor system ④
#[tokio::main]
async fn main() -&gt;Result&lt;()&gt; {
    let mut actor_system = ActorSystem::new("greeter_app");

    let actor_handle = spawn_actor!( actor_system, "greeter", Greeter{name: "me"})?;
    actor_handle.send_msg( Greet("world")).await?;

    actor_system.process_requests().await?;

    Ok(())
}</code></pre></pre>
<p>This breaks down into the following four parts:</p>
<h3 id="①-define-actor-message-set"><a class="header" href="#①-define-actor-message-set">① define actor message set</a></h3>
<h3 id="②-define-actor-state"><a class="header" href="#②-define-actor-state">② define actor state</a></h3>
<h3 id="③-define-the-actor-tuple-incl-behavior"><a class="header" href="#③-define-the-actor-tuple-incl-behavior">③ define the actor tuple (incl. behavior)</a></h3>
<h3 id="④-instantiate-and-run-the-actor-system"><a class="header" href="#④-instantiate-and-run-the-actor-system">④ instantiate and run the actor system</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-actor-programming-model"><a class="header" href="#the-actor-programming-model">The Actor Programming Model</a></h1>
<p>Actors represent a concurrency programmming model that avoids shared memory between concurrent (and possibly parallel)
executions by means of message passing. Since its introduction in [^Hewitt73] it has been the subject of extensive
formalization but the essence is that</p>
<p class="standout">actors are concurrently executing objects that only communicate through messages, without sharing state</p>
<p>In addition, existing actor implementations also ensure that messages received by an actor are processed sequentially,
which basically allows to treat an actor implementation as sequential code. This significantly reduces the concurrency
related complexity of systems that use actors as their primary building blocks.</p>
<p>The Actor programming model as used by <code>odin_actor</code> revolves around five components:</p>
<img class="mono right" src="odin_actor/../img/actors-mono.svg" width="35%"/>
<ul>
<li>an <strong>ActorSystem</strong> that instantiates and manages actors</li>
<li>the <strong>Actors</strong> themselves as the units of concurrent execution</li>
<li><strong>ActorHandles</strong> as the public-facing actor component</li>
<li><strong>actor mailboxes</strong> that represent the (internal) message queues of actors</li>
<li><strong>actor state</strong> as the mutable, internal memory of an actor</li>
<li>a <strong>receive(msg)</strong> function that defines how the actor processes received messages</li>
</ul>
<p><strong>ActorSystems</strong> instantiate and monitor actors. In concrete implementations they include some scheduler that picks
runnable actors (with pending messages) and maps them to kernel threads. They can also be used to manage global
resources (such as job schedulers) and perform actor synchronization (i.e. implement <code>ActorSystem</code> specific actor
state models)</p>
<p><strong>Actors</strong> are the concurrently executing entities. An actor aggregates a usually invisible <strong><code>mailbox</code></strong> (message queue),
an <strong>actor state</strong> that holds the (mutable) actor-specific data and a <strong><code>receive(msg)</code></strong> message handler function that can
in response to received messages</p>
<ul>
<li>mutate the actor state</li>
<li>create other actors</li>
<li>send messages to other actors</li>
</ul>
<p>It should be noted that <strong>Actors</strong> are an abstract concept - concrete ActorSystem implementations have considerable
leeway to implement them. They can use message queues and actor state outside of physical actor objects. Actors
can even be implemented as "behavior" function objects that pass in the state as a message handler argument, and use the
message handler return value to set the next behavior and/or state.</p>
<p><strong>ActorHandles</strong> represent the visible reference of an actor towards other actors and the actor system. The role of
an <strong>ActorHandle</strong> is to allow sending messages to the associated actor without exposing its internal state or directly
affecting its lifetime.</p>
<p>The original actor programming model is abstract. It does not concern itself with implementation specifics such as
type safety, e.g. to statically check that we can only send messages to actors that can handle them. However, those
programming language specific aspects can have a profound impact on genericity and safety of actor system frameworks
(e.g. to ensure that we do not leak actor state through references passed in messages).</p>
<p>Concrete implementations should also specify</p>
<ul>
<li>mailbox/send semantics (unbounded -&gt; non-blocking send, bounded -&gt; blocking when receiver queue is full)</li>
<li>message processing order (e.g. <em>sequential-per-sender</em>)</li>
</ul>
<p>Especially the first topic is relevant to address potential <em>back-pressure</em> in actor systems (slow receivers blocking
fast senders).</p>
<p>[^Hewitt73]	: Carl Hewitt; Peter Bishop; Richard Steiger (1973). "A Universal Modular Actor Formalism for Artificial Intelligence". IJCAI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-design"><a class="header" href="#basic-design">Basic Design</a></h1>
<p>This chapter describes how the general actor constructs introduced in [actor_basics] are implemented.</p>
<p>two underlying abstractions that can be varied: async runtime and channel implementation
channel impl controlled by features</p>
<h2 id="messages-and-actor-message-sets"><a class="header" href="#messages-and-actor-message-sets">Messages and Actor Message Sets</a></h2>
<h2 id="mailboxe"><a class="header" href="#mailboxe">Mailboxe</a></h2>
<h2 id="actorhandle"><a class="header" href="#actorhandle">ActorHandle</a></h2>
<h2 id="actor-state"><a class="header" href="#actor-state">Actor State</a></h2>
<h2 id="actor"><a class="header" href="#actor">Actor</a></h2>
<h2 id="actorsystem"><a class="header" href="#actorsystem">ActorSystem</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor-communication"><a class="header" href="#actor-communication">Actor Communication</a></h1>
<p>Actors don't live in isolation - their whole purpose is to build modular, scalable concurrent systems out of sets of
communicating actors. We therefore need to define</p>
<ul>
<li>what can be sent between actors (messages),</li>
<li>how we can send messages</li>
<li>how to program sender actors when, what and to whom messages should be sent</li>
</ul>
<p>Moreover, in <code>odin_actor</code> we need to do this in a type-safe, statically checked way. Since our implementation language
is Rust we want to ensure that</p>
<ul>
<li>we can only send thread- and memory-safe messages</li>
<li>we can only send messages to actors that handle them (are in the receiver's message interface)</li>
<li>each actor behavior is complete (no forgotten messages in the actor implementation)</li>
<li>actors combine (we can build systems out of generic actors that only need to know a minimum about each other)</li>
</ul>
<p>While the first three requirements are supported by Rust in a straight forward way, the forth requirement is complex.
Let's take it one step at a time.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>This one is easy - <code>odin_actor</code> does not have a specific message type or trait. Anything that is <code>Send</code> + <code>Debug</code> +
<code>'static</code> can be a message. The <code>Send</code> constraint is obvious as we pass messages between concurrent tasks (actors).
The<code>Debug</code> constraint is only for generic tracing/debugging support. The message type needs to be <code>static</code> since it is
part of the receiver actors definition. Some message sender methods do also require <code>Clone</code> as all sender methods do
consume the message argument. Should cloning be inefficient the message can also be an <code>Arc&lt;T&gt;</code>.</p>
<p>Since an actor typically processes more than one message we need to wrap all of its input message types into an <code>enum</code>.
This message set becomes part of the generic <code>Actor&lt;MsgSet,ActorState&gt;</code> type. Defining the message set is supported by
the <code>define_actor_msg_set!{..}</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_actor_msg_set! { MyActorMsg = Msg1 | Msg2 }
<span class="boring">}</span></code></pre></pre>
<p>which roughly expands to</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// automatically generated code
enum MyActorMsg {
   Msg1(Msg1),                // user messages...
   Msg2(Msg2),                
   _Start_ (_Start_),         // system messages...
   ... 
   _Terminate_ (_Terminate_) 
}
impl From&lt;Msg1&gt; for MyActorMsg { ... }
impl From&lt;Msg2&gt; for MyActorMsg { ... }
...
<span class="boring">}</span></code></pre></pre>
<p>The macro automatically adds variants for each of the system messages</p>
<ul>
<li><code>_Start_</code> - sent by the <code>ActorSystem</code> to indicate that all actors have been instantiated and should start to process</li>
<li><code>_Timer_</code> - sent by timers created from within the actor</li>
<li><code>_Exec_</code> - a generic message that executes the provided closure within the actor task</li>
<li><code>_Pause_</code> and <code>_Resume_</code> - can be used by actor systems that replay content</li>
<li><code>_Terminate_</code> - sent by the <code>ActorSystem</code> to indicate the application is about to shut down</li>
</ul>
<p>System messages don't need to be explicitly handled. They are sent either by the <code>ActorSystem</code> (e.g. <code>_Start_</code>) or
implicitly by <code>Actor</code> methods such as <code>start_timer(..)</code> or <code>exec(..)</code>.</p>
<p>The message set name (e.g. <code>MyActorMsg</code>) is then used to define the actor like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl_actor! { match msg for Actor&lt;MyActorMsg,MyActorState&gt; as
  Msg1 =&gt; ... // handle message 'msg' of type 'Msg1'
  Msg2 =&gt; ...
}
<span class="boring">}</span></code></pre></pre>
<p>Both <code>define_actor_msg_set!{..}</code> and <code>impl_actor!{..}</code> automatically translate generic message types (e.g. <code>Query&lt;Q,A&gt;</code>)
into valid variant names of the actor message set. Although this mapping is readable and intuitive the programmer does not
need to know (other than to understand related compiler error messages).</p>
<p>Using an enum to encode all possible input messages for an actor also explains why message types should not be large. Not
only would this increase <code>clone()</code> cost but it also would enlarge the message set enum, which is sized according to its largest
variant.</p>
<p><a id="message-size"></a>
Since this message set enum is the type of the actor mailbox (channel) this size matters - a Rust <code>enum</code> is sized according to
its largest variant. If the ratio of max to min size of variants is too large then the channel can waste a lot of memory. If this is a problem we can always wrap (part of) large messages within heap-allocated containers (<code>Box</code>, <code>Arc</code>, <code>Vec</code> etc.) which collapses the size of the wrapped data to a pointer.</p>
<h2 id="how-to-send-messages"><a class="header" href="#how-to-send-messages">How to Send Messages</a></h2>
<p>Actor mailboxes in <code>odin_actor</code> are implemented as bounded async channels. This means sending messages can block the
sender if the receiver queue is full. Since it depends on the actor/message types if this is acceptable we need to support
alternative send operations:</p>
<ul>
<li><code>send_msg(msg)</code> - this is an <code>async</code> function that can suspend the sender and hence can only be called from an <code>async</code> context</li>
<li><code>timeout_send_msg(msg,timeout)</code> - also <code>async</code> but guaranteed to finish in bounded time, possibly returning a timeout error</li>
<li><code>try_send_msg(msg)</code> - sync call. returning an error of the receiver queue is full</li>
<li><code>retry_send_msg(max_attempts,delay,msg)</code> - also sync but re-scheduling the message if receiver queue is full</li>
</ul>
<p>It is important to note that <code>retry_send_msg(..)</code> <em>can</em> violate the property that messages from the <em>same sender</em> are
processed by the receiver in the order in which they were sent. If partial send order is required this has to be
explicitly enforced in the sender.</p>
<p>All send operations return <code>Result&lt;(),OdinActorError&gt;</code> values. Senders should handle <code>ReceiverClosed</code> and - for async sends -
<code>ReceiverFull</code> and/or <code>Timeout</code> error values.</p>
<p>Send methods are defined in <code>ActorHandle</code>, <code>MsgReceiver</code> and <code>Actor</code> (the latter one used to send messages to itself).</p>
<p>Normal message send operations are unidirectional - should the sender expect a response that needs to retain request
information the responder has to do this association explicitly (e.g. by copying relevant request info into the response message, or by keeping a list of pending requests in the sender).</p>
<h2 id="waiting-for-a-response---queryqa"><a class="header" href="#waiting-for-a-response---queryqa">Waiting for a Response - <code>Query&lt;Q,A&gt;</code></a></h2>
<p>The bi-directional <code>query(..)</code> operations overcome this restriction in cases where the sender should wait for a response
before going on. The underlying message type is a generic <code>Query&lt;Question,Answer&gt;</code> struct which has to be in the
responders input message set, the concrete <code>Question</code> and <code>Answer</code> types being provided by the user (with normal message
type constraints).</p>
<p>The requester sends queries like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
  let question = ... 
  match query( responder_handle, question).await {
     Ok(response) =&gt; ... // process response value
     Err(e) =&gt; ... // handle failed query
  }
<span class="boring">}</span></code></pre></pre>
<p>The corresponding responder code would be:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_actor_msg_set! { ResponderMsg = ... | Query&lt;Question,Answer&gt; | ...}

impl_actor!{ match msg for Actor&lt;ResponderMsg,ResponderState&gt; as
  ...
  Query&lt;Question,Answer&gt; =&gt; {
     let answer = ...
     if let Err(e) = msg.respond( answer).await {
       ...// handle response send error
     }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>In many other actor system libraries this is known as the <em>ask pattern</em>.</p>
<p>If the requester message processing should not be blocked (i.e. there are other messages the requester still has to
react to while waiting for a response) the query should be performed from a spawned task. Since the task closure can
capture the query context (e.g. the question) this can still be preferrable to explicit request/response mapping for
one-way messages.</p>
<p>Due to this round trip (and potential per request response channel allocation) queries are less efficient than
normal message send operations. For repetitive queries from within the same requester there is a <code>QueryBuilder</code>
that avoids the response channel allocation for consecutive queries of the same type.</p>
<h2 id="how-to-make-senders-generic---receivers-and-actions"><a class="header" href="#how-to-make-senders-generic---receivers-and-actions">How to Make Senders Generic - Receivers and Actions</a></h2>
<p>This is the big topic for typed actor communication in (open) actor system frameworks:</p>
<p class="standout">how to connect actors from different domains that do not know about each other?</p>
<p>In other words - how do we make actors in open actor systems reusable in different contexts. This is not a
problem if actors are just used in a single application or a single domain (such as a generic web server) - here the set
of actor and message types is closed and known a priori. It becomes a vital problem for a framework such as <code>odin_actor</code>
that is meant to be extended by 3rd parties and for various kinds of applications.</p>
<p>This section describes the levels at which we can separate sender and receiver code in <code>odin_actor</code>,</p>
<p>The basis for all this is how we can specify the receiver of a particular message within the sender</p>
<h3 id="1-actorhandlem" class="bottom-sep"><a class="header" href="#1-actorhandlem">(1) <code>ActorHandle&lt;M&gt;</code></a></h3>
<p><code>ActorHandle&lt;M&gt;</code> fields can be used to send messages of any variant of the message set that is defined by the
<code>define_actor_msg_set</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_actor_msg_set!{ MyMsgSet = Msg1 | Msg2 | ..}
...
impl_actor! { match msg for Actor&lt;MyMsgSet,MyActorState&gt; as 
   Msg1 =&gt; ...
   Msg2 =&gt; ...
   ...
}
<span class="boring">}</span></code></pre></pre>
<p>This is the least amount of separation between sender and receiver since the sender has to know the full message
interface of the receiver (e.g. <code>MyMsgSet</code>), not only the message it wants to send (e.g. <code>Msg2</code>). In most cases this is
synonym to knowing the concrete type of the receiver actor, which practically limits this mechanism to very general
receivers or to actors from the same domain (i.e. actors that know about their concrete types anyways).</p>
<p><code>ActorHandle&lt;M&gt;</code> is a <code>struct</code> that is <code>Clone</code> + <code>Send</code>, hence it can be sent in messages and stored in fields.
Cloning <code>ActorHandle</code> is inexpensive.</p>
<h3 id="2-msgreceivert-and-msgreceiverlistt" class="bottom-sep"><a class="header" href="#2-msgreceivert-and-msgreceiverlistt">(2) <code>MsgReceiver&lt;T&gt;</code> and <code>MsgReceiverList&lt;T&gt;</code></a></h3>
<p><code>MsgReceiver&lt;T&gt;</code> can be used to send messages of a single type <code>T</code> to the receiver (if <code>T</code> is in the receiving actors
message set - see above). This is the next level of separation since now the sender only has to know that the receiver
understands <code>T</code> - it does not need to know what other messages the receiver processes.</p>
<p><code>ActorHandle&lt;M&gt;</code> has a blanket impl for <code>MsgReceiver&lt;T&gt;</code> for all variants of its message set <code>M</code>.</p>
<p><code>MsgReceiver&lt;T&gt;</code> is a trait, which means it can only be stored within the sender using a type variable</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MySender&lt;R&gt; where R: MsgReceiver&lt;SomeMsg&gt; {
   receiver: R, ...
}
<span class="boring">}</span></code></pre></pre>
<p>To support heterogenous lists of <code>MsgReceiver&lt;T&gt;</code> implementors we provide a <code>MsgReceiverList&lt;T&gt;</code> trait together with
a <code>msg_receiver_list!(..)</code> macro that can be used like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   //--- receiver actor module(s)
   define_actor_msg_set! { Receiver1Msg =  Msg1 | ... }
   define_actor_msg_set! { Receiver2Msg =  ... | Msg1 | ... }
   ...
   struct Receiver1 { ... }
   struct Receiver2 { ... }

   //--- sender actor module
   struct MySender&lt;L&gt; where L: MsgReceiverList&lt;Msg1&gt; {
      receivers: L, ...
   }
   impl&lt;L&gt; MySender&lt;L&gt; where L: MsgReceiverList&lt;Msg1&gt; {
      ... self.receivers.send_msg( Msg1{...}, true).await ...
   }

   //--- actor system construction (main)
   let receiver1_handle = spawn_actor!( actor_system, "recv1", Receiver1 {..});
   let receiver2_handle = spawn_actor!( actor_system, "recv2", Receiver2 {..});

   spawn_actor!( actor_system, "sender", 
                 Sender::new( msg_receiver_list!( receiver1_handle, receiver2_handle : MsgReceiver&lt;Msg1&gt;) ))
<span class="boring">}</span></code></pre></pre>
<p><code>MsgReceiverList&lt;T&gt;</code> has the usual send functions but adds a <code>ignore_err: bool</code> argument to each of them, defining
if the send operation for the list should ignore error results for its elements. If set to false, the first element
send operation that fails shortcuts the list send operation.</p>
<p><code>MsgReceiver&lt;T&gt;</code> and <code>MsgReceiverList&lt;T&gt;</code> represent static receiver types - with them we cannot dynamically add
new receivers at runtime.</p>
<h3 id="3-dynmsgreceivert-and-dynmsgreceiverlistt" class="bottom-sep"><a class="header" href="#3-dynmsgreceivert-and-dynmsgreceiverlistt">(3) <code>DynMsgReceiver&lt;T&gt;</code> and <code>DynMsgReceiverList&lt;T&gt;</code></a></h3>
<p><code>DynMsgReceiver&lt;T&gt;</code> is a type that allows us to send and store <code>MsgReceiver&lt;T&gt;</code> implementors as trait objects at
runtime. It is boxing a normally transparent <code>DynMsgReceiverTrait&lt;T&gt;</code> for which <code>ActorHandle&lt;M&gt;</code> has blanket impls.
It is less efficient than the static <code>MsgReceiver&lt;T&gt;</code> since it incurs extra runtime cost for each send
operation (pin-boxing the futures returned by its send operations).</p>
<p><code>DynMsgReceiverList&lt;T&gt;</code> is a container for <code>DynMsgReceiver&lt;T&gt;</code> objects. It is used like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   //--- receiver actor module(s)
   define_actor_msg_set! { Receiver1Msg =  Msg1 | ... }
   
   struct Receiver1&lt;S&gt; where S: MsgReceiver&lt;AddMsg1Receiver&gt; { sender: S... }

   impl_actor! { match msg for Actor&lt;Receiver1&lt;S&gt;,Receiver1Msg&gt; where S: MsgReceiver&lt;AddMsg1Receiver&gt; as
      ... self.sender.send_msg( AddMsg1Receiver(self.hself.into())).await ...
      Msg1 =&gt; ...
   }

   define_actor_msg_set! { Receiver2Msg =  ... | Msg1 | ... }
   struct Receiver2&lt;S&gt; where S: MsgReceiver&lt;AddMsg1Receiver&gt; { sender: S... }
   ...

   //--- sender actor module
   #[derive(Debug)]
   struct AddMsg1Receiver(DynMsg1Receiver&lt;Msg1&gt;);

   define_actor_msg_set! { MySenderMsg = AddMsg1Receiver | ...}

   struct MySender  {
      receivers: DynMsgReceiverList&lt;Msg1&gt;, ...
   }

   impl_actor! { match msg for Actor&lt;MySender,MySenderMsg&gt; as 
      AddMsg1Receiver =&gt; cont! { self.receivers.push(msg.0) }
      ...
      ... self.receivers.send_msg( Msg1{..}, true).await ...
   }

   //--- actor system construction (main)
   let sender = spawn_actor!( actor_system, "sender", MySender {..});
   spawn_actor!( actor_system, "recv1", Receiver1{sender, ...});
   spawn_actor!( actor_system, "recv2", Receiver2{sender, ...});
<span class="boring">}</span></code></pre></pre>
<p><code>MsgReceiverList&lt;T&gt;</code> and <code>DynMsgReceiverList&lt;T&gt;</code> are used to implement static/dynamic publish/subscribe patterns.
They allow us to abstract concrete receiver types our sender can communicate with, provided all these
receivers have the message type we send in their message set.</p>
<p>The limitations are that both sender and receivers have to know the respective message type, and the sender has
to know how to instantiate that message. This is a serious constraint for multi-domain frameworks.</p>
<h3 id="4-dataactiont-and-the-data_action-macro" class="bottom-sep"><a class="header" href="#4-dataactiont-and-the-data_action-macro">(4) <code>DataAction&lt;T&gt;</code> and the <code>data_action!{..}</code> macro</a></h3>
<p><code>DataAction&lt;T&gt;</code>is an abstraction that overcomes the limitation of being able to send only one message type
and having to hard-code message construction in the sender actor (which might not know the messages understood
by potential receivers).</p>
<p>Data actions are defined and documented in the [<code>odin_action</code>] crate - while the <strong>action</strong> construct is not
actor specific it is most useful to make actors from different domains inter-operable. They can be viewed as
async "callbacks" that allow the sender to inject its own data into action executions. All the sender actor
has to know is when to execute an action and what data to provide for its execution.</p>
<p>Actions can be defined explicitly as in:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   // sender actor definition 
   struct Sender&lt;A&gt; where A: DataAction&lt;SenderData&gt; {
       action: A, ...
   }
   impl&lt;A&gt; Sender&lt;A&gt; where A: DataAction&lt;SenderData&gt; {
       ...
         let data: SenderData = ...; // create the data that should be passed into the action
         self.action.execute( data ).await ...
   }
   ...
   // action definition (at the actor system construction site, e.g. main())
   struct MyDataAction {..}
   impl DataAction&lt;SenderData&gt; for MyAction {
       async fn execute (data: &amp;SenderData)-&gt;Result&lt;()&gt; { ... } // ⬅︎ concrete action defined here
   }

   ...  Sender::new( MyDataAction{..}, ...)
<span class="boring">}</span></code></pre></pre>
<p>More often actions are one-of-a-kind objects that are defined and instantiated through the macros that are
provided by [<code>odin_action</code>], and their action expressions are sending messages to other actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // actor modules
  define_actor_msg_set! { Receiver1Msg = Msg1 | ... }
  define_actor_msg_set! { Receiver2Msg = ... | Msg2 | ... }
  ...
  struct Sender&lt;A&gt; where A: DataRefAction&lt;SenderData&gt; { 
     data: SenderData,
     action: A, ...
  }
  impl&lt;A&gt; Sender&lt;A&gt; where A: DataRefAction&lt;SenderData&gt; {
    fn new (action: A)-&gt;Self { ... }

    ... self.action.execute(&amp;self.data).await ...
  }
  
  // actor system construction site (e.g. main() function)
     receiver1 = spawn_actor!( actor_system, "recv1", Receiver1{..})?;
     receiver2 = spawn_actor!( actor_system, "recv1", Receiver1{..})?;
     ...
     sender = spawn_actor!( actor_system, "sender", Sender::new(
         dataref_action!( receiver1: ActorHandle&lt;Receiver1Msg&gt;, receiver2: ActorHandle&lt;Receiver2Msg&gt; =&gt; |data: &amp;SenderData| {
            receiver1.send_msg( Msg1::new( ...data.clone().,,)).await?;
            receiver2.try_send_msg( Msg2::new(...data.translate() ...))
         })
     ))?;
<span class="boring">}</span></code></pre></pre>
<p>The interesting aspect about the <code>data_action!(..)</code> macros is that they can capture data from the macro call site without
requiring a closure (Rust does not yet support async closures). The general pattern of the macro call is as follows:</p>
<pre><code>data_action!( «captured-receiver-var» :  «capture-type», ... =&gt; |«data-var»: «data-var-type»| «execute-expr»)
</code></pre>
<p>While data actions effectively separate sender and receiver code there is one last constraint: data actions have to be created
upfront, at system construction time. We cannot send them to actors.</p>
<h3 id="6-dyndataactiont-and-the-dyn_data_action-macro" class="bottom-sep"><a class="header" href="#6-dyndataactiont-and-the-dyn_data_action-macro">(6) <code>DynDataAction&lt;T&gt;</code> and the <code>dyn_data_action!{..}</code> macro</a></h3>
<p>The [<code>odin_action</code>] crate also supports dynamic (trait object) actions through its [<code>dyn_data_action</code>] and [<code>dyn_dataref_action</code>]
macros, which does allow to send actions in messages. This is in turn useful to</p>
<ul>
<li>execute such actions when the receiver processes the containing message</li>
<li>store actions for later execution (e.g. in a subscriber list)</li>
</ul>
<p>To store action trait objects and execute their entries [<code>odin_action</code>] provides the [<code>DynDataActionList</code>] and
[<code>DynDataRefActionList</code>] containers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// receiver actor impl module
struct Msg1 { .. }
...
define_actor_msg_set { ReceiverMsg = Msg1 | ... }
...
impl_actor! { match msg for Actor&lt;ReceiverMsg,Receiver&gt; as
   Msg1 =&gt; ...
   ...
}

// sender actor impl module
struct AddUpdateAction(DynDataRefAction&lt;SenderData&gt;)
...
define_actor_msg_set { SenderMsg = AddUpdateAction | PublishChanges | ... }

struct Sender {
   data: SenderData,
   update_action: DynDataRefActionList&lt;SenderData&gt; 
   ...
}
impl_actor! { match msg for Actor&lt;SenderMsg,Sender&gt; as
   AddUpdateAction =&gt; { ... self.update_action.push( msg.0) ... }
   PublishChanges =&gt; { ... self.update_action.execute( &amp;self.data).await ... }
   ...
}
...
// actor system construction module
...
receiver = spawn_actor!( actor_system, "receiver", Receiver::new(..))?;
sender = spawn_actor!( actor_system, "sender", Sender::new(..))?;
...
let action = send_msg_dyn_action!( receiver, |data: &amp;SenderData| Msg1::new(data));
sender.send_msg( AddUpdateAction(action)).await?;
<span class="boring">}</span></code></pre></pre>
<p>Actions sent in messages can also be executed when the receiver processes such messages. Since dyn actions can capture
data from the creation site (within the sender code) this can be useful as a less expensive alternative to the <code>query()</code>
mechanism described above (only using the normal actor task context).</p>
<p>With power comes responsibility - being able to use loops within action bodies we have to be aware of two potential
problems:</p>
<ul>
<li>back pressure and</li>
<li>loss-of-information</li>
</ul>
<p>The back pressure problem arises if we send messages from within iteration cycles, as in:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>... dataref_action( ... |data: &amp;Vec&lt;SomeData&gt;| {...
      for e in data {
         ... receiver.try_send_msg( SomeMessage::new(e)); ...
      }
    }) ...
<span class="boring">}</span></code></pre></pre>
<p>This can result in <code>OdinActorError::ReceiverFull</code> results when sending messages. If we use <code>try_send_msg(..)</code> without
processing the return value (as in above snippet) this might even be silently ignored. The solution for this is to
either check the return value or use</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>         ... receiver.send_msg( SomeMessage::new(e)).await ...
<span class="boring">}</span></code></pre></pre>
<p>In this case we have to be aware though that the sender might get blocked, i.e. becomes un-responsive if it is also
a potential message receiver. Should this apply we can run the loop from within a spawned task.</p>
<p>There also might be a (semantic) loss-of-information problem if we need to preserve that all messages sent from within
the loop came from the same input data (the <code>execute()</code> argument). Unless receivers could easily reconstruct this from
the respective message payload the solution is to collect the payloads into a container and send that container as one
message, which turns the above case into:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>... dataref_action( ... |data: &amp;Vec&lt;SomeData&gt;| {...
      let msg_payload: Vec&lt;SomePayload&gt; = data.iter().map(|e| payload(e)).collect();
      receiver.try_send_msg( SomeMessage::new( msg_payload)) ...
    }) ...
<span class="boring">}</span></code></pre></pre>
<p>This also addresses the message variant size problem mentioned (above)[#message-size].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>
<p>The <code>odin_actor/examples</code> directory contains a set of runnable example applications that each introduce and demonstrate a single
<code>odin_actor</code> feature. It is recommended to go through examples in the following sequence:</p>
<ul>
<li><a href="odin_actor/examples/odin_actor/examples/hello_world.html"><code>hello_world</code></a> : the basics (actorsystem, actor and sending messages)</li>
<li><a href="odin_actor/examples/odin_actor/examples/sys_msgs.html"><code>sys_msgs</code></a> : using system messages and timers</li>
<li><a href="odin_actor/examples/odin_actor/examples/spawn.html"><code>spawn</code></a> : spawning one-shot async tasks from within actors</li>
<li><a href="odin_actor/examples/odin_actor/examples/spawn_blocking.html"><code>spawn_blocking</code></a> : spawn blocking tasks (running in threads) from within actors</li>
<li><a href="odin_actor/examples/odin_actor/examples/exec.html"><code>exec</code></a> : using the generic <code>exec(..)</code> to execute closures within actor tasks</li>
<li><a href="odin_actor/examples/odin_actor/examples/jobs.html"><code>jobs</code></a> : scheduling generic jobs with the actor system global <code>JobScheduler</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/producer_consumer.html"><code>producer_consumer</code></a> : point-to-point actor communication with <code>MsgReceiver</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/pub_sub.html"><code>pub_sub</code></a> : publish/subscribe communication using a static <code>MsgReceiverList&lt;T&gt;</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/dyn_pub_sub.html"><code>dyn_pub_sub</code></a> : dynamic publish/subscribe communication using <code>DynMsgReceiver&lt;T&gt;</code> and <code>DynMsgReceiverList&lt;T&gt;</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/pin_pong.html"><code>ping_pong</code></a> : managing cyclic actor dependencies with <code>PreActorHandle</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/query.html"><code>query</code></a> : using <code>Query&lt;Q,A&gt;</code> to send a message and wait for an answer</li>
<li><a href="odin_actor/examples/odin_actor/examples/dyn_actor.html"><code>dyn_actor</code></a> : dynamically create actors from within actors</li>
<li><a href="odin_actor/examples/odin_actor/examples/actions.html"><code>actions</code></a> : statically configure actor interaction with <code>DataAction</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/dyn_actions.html"><code>dyn_actions</code></a> : dynamically configure actor interaction with <code>DynDataAction</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/retry.html"><code>retry</code></a> : handling back-pressure with <code>retry_send_msg(..)</code></li>
<li><a href="odin_actor/examples/odin_actor/examples/requests.html"><code>requests</code></a> : sequential processing of requests in background task</li>
<li><a href="odin_actor/examples/odin_actor/examples/actor_config.html"><code>actor_config</code></a> : configuring actors with the <code>config_for!(..)</code> macro</li>
<li><a href="odin_actor/examples/odin_actor/examples/heartbeat.html"><code>heartbeat</code></a> : monitoring actor systems with heartbeat messages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello_world"><a class="header" href="#hello_world">hello_world</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sys_msgs"><a class="header" href="#sys_msgs">sys_msgs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn"><a class="header" href="#spawn">spawn</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn_blocking"><a class="header" href="#spawn_blocking">spawn_blocking</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exec"><a class="header" href="#exec">exec</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jobs"><a class="header" href="#jobs">jobs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="producer_consumer"><a class="header" href="#producer_consumer">producer_consumer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pub_sub"><a class="header" href="#pub_sub">pub_sub</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ping_pong"><a class="header" href="#ping_pong">ping_pong</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query"><a class="header" href="#query">query</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn_actor"><a class="header" href="#dyn_actor">dyn_actor</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions"><a class="header" href="#actions">actions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn_actions"><a class="header" href="#dyn_actions">dyn_actions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retry"><a class="header" href="#retry">retry</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requests"><a class="header" href="#requests">requests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor_config"><a class="header" href="#actor_config">actor_config</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heartbeat"><a class="header" href="#heartbeat">heartbeat</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_server"><a class="header" href="#odin_server">odin_server</a></h1>
<p>The <code>odin_server</code> crate provides actors that encapsulate servers. The primary server type is the <code>SpaServer</code> that
implements a <a href="https://en.wikipedia.org/wiki/Single-page_application"><em>Single Page Application</em></a> web server model
with composable <code>SpaService</code> (<a href="https://en.wikipedia.org/wiki/Microservices"><em>Micro Service</em></a>) stacks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-domain-crates"><a class="header" href="#application-domain-crates">Application Domain Crates</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_sentinel"><a class="header" href="#odin_sentinel">odin_sentinel</a></h1>
<p>The <code>odin_sentinel</code> crate is a user (data) crate for retrieval, realtime import and processing of <a href="https://delphiretech.com/products/">Delphire
Sentinel</a> fire sensor data. Sentinel sensor devices are smart in-field devices that
use on-board AI to detect fire and/or smoke from a mix of sensor data such as visual/infrared cameras and chemical
sensors. The goal is to minimize latency for fire detection <em>and</em> in-field communication related power consumption.</p>
<p>The <code>odin_sentinel</code> crate accesses respective Sentinel data through an external Delphire server, it does not directly communicate with in-field devices. This external server provides two communication channels:</p>
<ul>
<li>an http query api to retrieve device capabilities and sensor record data</li>
<li>a websocket based push notification for new record data availability</li>
</ul>
<p>The primary component running in the ODIN server is a <code>SentinelActor</code>, which is a realtime database of a configurable
number of most recent sentinel sensor records. The <code>SentinelActor</code> does not directly communicate with the outside world - it
uses a <code>SentinelConnector</code> trait object to do external IO. The primary impl for this trait is the <code>LiveSentinelConnector</code>,
which retrieves the list of available Sentinel devices, queries each devices sensors and retrieves initial sensor records
(all using HTTP GET requests). It then opens a websocket and listens for incoming sensor record availability notifications
(as JSON messages). Once such a notification was received the connector uses HTTP GET to retrieve the record itself and
informs client actors about the update.</p>
<pre><code>                                                                                        [sentinel_alarm.ron] config
                                                               ┌─────────────────────────────────────╎─────┐                  
                                                               │ ODIN Server           ┌─────────────╎───┐ │                  
                                                               │                       │ AlarmActor  ╎   │ │                  
                                                 - devices     │                ┌─────▶︎│  ┌──────────▼┐  │ │                  
                                                 - sensors     │                │      │  │Alarm      ├─┐│ │                  
                            ┌─────────────────┐  - sensor-     │ ┌──────────────┴──┐   │  │ Messenger │ │────────▶︎ phone      
┌────────┐                  │ Delphire Server │     records    │ │ SentinelActor   │   │  └┬──────────┘ ││ │                
|        ├─┐                │                 │                │ │ ┌─────────────┐ │   │   └────────────┘│ │                  
│Sentinel│ │─ satellite ───▶︎│  ┌───────────┐  ├───── http ────────▶︎│             │ │   └─────────────────┘ │                  
│        │ │      or        │  │  record   │  │                │ │ │LiveConnector│ │                       │                  
└┬───────┘ │── cellular ───▶︎│  │ database  │  ├─── websocket ─────▶︎│             │ │   ┌─────────────────┐ │                  
 └─────────┘                │  └───────────┘  │                │ │ └─▲───────────┘ │   │ WebServerActor  │ │                  
                            │                 │ - notification │ └───╎──────────┬──┘   │ ┌────────────┐  │ │                  
                            └─────────────────┘                │     ╎          │      │ │  Sentinel  ├─┐│ │                  
                                                               │     ╎          └─────▶︎│ │   Service  │ │────────▶︎ web        
                                                               │     ╎                 │ └┬──────▲────┘ ││ │     browser      
                                            [sentinel.ron]╶╶╶╶╶╶╶╶╶╶╶┘                 │  └──────╎──────┘│ │                  
                                              config           │                       └─────────╎───────┘ │                  
                                                               └─────────────────────────────────╎─────────┘ 
                                                                                          [odin_sentine.json] asset                 
</code></pre>
<p>Although <code>SentinelActor</code> can be connected to any client actor using <code>odin_action</code> for message interactions the <code>odin_sentinel</code> crate
includes two primary clients / client-components: <code>SentinelAlarmActor</code> and <code>SentinelSpaService</code>.</p>
<p>The <code>SentinelAlarmActor</code> is used to listen for incoming updates about fire and smoke alarms that have not been reported yet, retrieves respective
evidence (images), and then uses a configurabe set of <code>AlarmMessenger</code> trait objects to report new alarms to the outside world. The primary
choice for production messengers is the <code>SlackAlarmMessenger</code> that pushes notifications to configurable slack channels.</p>
<p>The <code>SentinelSpaService</code> implements a <code>odin_server::SpaService</code> to add a sentinel channel to a single page web application.</p>
<p>The specification of Sentinel data records with respective http access APIs can be found on <a href="http://38.99.249.67:2361/api/">Delphire's Documentation Server</a>. Access of realtime Sentinel data is protected and requires an authentication token from Delphire that can be stored/retrieved in <code>odin_sentinel</code> applications via the [<code>odin_config</code>] crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odin_goesr"><a class="header" href="#odin_goesr">odin_goesr</a></h1>
<p>This is a user domain crate that supports download and processing of NASA/NOAAs Geostational Operational Environmental Satellite (GOES)
data. At the time of this writing (05/2024) there are two operational satellites: GOES-16 (aka GOES-east) and GOES-18 (aka GOES-west)
observing North and South America. The primary instrument used is the <a href="https://www.ncei.noaa.gov/access/metadata/landing-page/bin/iso?id=gov.noaa.ncdc:C01520">Advanced Baseline Imager (ABI)</a>. The <a href="https://www.goes-r.gov/products/docs/PUG-L2+-vol5.pdf">Product User Guide (PUG) vol. 5</a> contains information about
available data products and formats.</p>
<p>ODIN currently supports the L2 FDCC (Fire/Hotspot Characerization) data product, with future plans for additional data sets such as geo-color
images and lightining detection. Details about FDCC data can be found in the PUG (pg. 472pp).</p>
<p>Data is downloaded from the following AWS S3 buckets:</p>
<ul>
<li><a href="https://noaa-goes16.s3.amazonaws.com/index.html">GOES-16</a></li>
<li><a href="https://noaa-goes18.s3.amazonaws.com/index.html">GOES-18</a></li>
</ul>
<p>which are updated in a 5min interval (data becomes available with +/- 20sec).</p>
<p>The main functions (and general progressions) of this user domain data crate are:</p>
<ol>
<li>timely (minimal latency) data retrieval</li>
<li>translation of external data format (<a href="https://www.unidata.ucar.edu/software/netcdf/">NetCDF</a>) into internal data model</li>
<li>async import/notification with import actor</li>
<li>web (micro) service for browser based visualization (TBD)</li>
<li>archive replay (TBD)</li>
</ol>
<h2 id="modules"><a class="header" href="#modules">modules</a></h2>
<ul>
<li>the main <code>lib</code> module contains the common data model and general (non-application specific) functions to download and translate
respective AWS data sets</li>
<li>the <code>geo</code> module holds functions to compute geodetic coordinates from GOES-R scan angles</li>
<li><code>live_importer</code> does the download schedule computation and realtime data import from AWS S3. It also contains definition of
respective configuration data</li>
<li><code>actor</code> holds the import actor definition that makes the internal data model available in an actor context that provides three
action points (see [odin_action])
<ul>
<li>init (taking the initial data as action input)</li>
<li>update (for each new data set)</li>
<li>on-demand snapshot (requested per message, taking the whole current data as action input)</li>
</ul>
</li>
<li><code>errors</code> has the error type definition for the <code>odin_goesr</code> crate</li>
</ul>
<h2 id="tool-executables"><a class="header" href="#tool-executables">tool executables</a></h2>
<ul>
<li><code>download_goesr_data</code> bin - this is both for testing the download schedule and for retrieving raw data during production</li>
<li><code>read_goesr_hotspots</code> bin - this is a test and production tool to translate single downloaded files into the internal data format</li>
</ul>
<h2 id="example-executables"><a class="header" href="#example-executables">example executables</a></h2>
<ul>
<li><code>goesr_actor</code> example - this shows how to instantiate and connect a [<code>GoesRHotspotImportActor</code>]</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-glossary"><a class="header" href="#4-glossary">4 Glossary</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
